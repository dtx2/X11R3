\&
.sp 1
.ce 3
\s+1\fBChapter 7\fP\s-1

\s+1\fBEvent Management\fP\s-1
.sp 2
.nr H1 7
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 7 \- Event Management
.XE
While X allows the reading and processing of events anywhere in an application,
widgets in the \*(tk neither directly read events
nor grab the server or pointer.
Widgets register procedures that are to be called
when an event or class of events occurs in that widget.
.LP
A typical application consists of startup code followed by an event loop
that reads events and dispatches them by calling
the procedures that widgets have registered.
The default event loop provided by the \*(xI is
.PN XtAppMainLoop .
.LP
The event manager is a collection of functions to perform the following tasks:
.IP \(bu 5
Add or remove event sources other than X server events (in particular,
timer interrupts and file input).
.IP \(bu 5
Query the status of event sources.
.IP \(bu 5
Add or remove procedures to be called when an event occurs for a particular
widget.
.IP \(bu 5
Enable and
disable the dispatching of user-initiated events (keyboard and pointer events)
for a particular widget.
.IP \(bu 5
Constrain the dispatching of events to a cascade of pop-up widgets.
.IP \(bu 5
Call the appropriate set of procedures currently registered when an event
is read.
.LP
Most widgets do not need to call any of the event handler functions explicitly.
The normal interface to X events is through the higher-level
translation manager,
which maps sequences of X events (with modifiers) into procedure calls.
Applications rarely use any of the event manager routines besides
.PN XtAppMainLoop .
.NH 2
Adding and Deleting Additional Event Sources
.XS
\fB\*(SN Adding and Deleting Additional Event Sources\fP
.XE
.LP
While most applications are driven only by X events,
some applications need to incorporate other sources of input 
into the \*(tk event handling mechanism.
The event manager provides routines to integrate notification of timer events
and file data pending into this mechanism.
.LP
The next section describes functions that provide input gathering from files.
The application registers the files with the \*(xI read routine.
When input is pending on one of the files,
the registered callback procedures are invoked.
.NH 3
Adding and Removing Input Sources
.XS
\fB\*(SN Adding and Removing Input Sources\fP
.XE
.LP
To register a new file as an input source for a given application, use
.PN XtAppAddInput .
.IN "XtAppAddInput" "" "@DEF@"
.FD 0
XtInputId XtAppAddInput(\fIapp_context\fP, \fIsource\fP, \fIcondition\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      XtAppContext \fIapp_context\fP;
.br
      int \fIsource\fP;
.br
      caddr_t \fIcondition\fP;
.br
      XtInputCallbackProc \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.ds Co that identifies the application
.IP \fIapp_context\fP 1i
Specifies the application context \*(Co.
.IP \fIsource\fP 1i
Specifies the source file descriptor on a UNIX-based system
or other operating system dependent device specification.
.IP \fIcondition\fP 1i
Specifies the mask that indicates a read, write, or exception condition
or some operating system dependent condition.
.ds Pr \ to be called when input is available
.IP \fIproc\fP 1i
Specifies the procedure that is\*(Pr.
.ds Cd input is available
.IP \fIclient_data\fP 1i
Specifies the argument that is to be passed to the specified procedure
when \*(Cd.
.LP
The
.PN XtAppAddInput
function registers with the \*(xI read routine a new source of events,
which is usually file input but can also be file output.
Note that file should be loosely interpreted to mean any sink 
or source of data.
.PN XtAppAddInput
also specifies the conditions under which the source can generate events.
When input is pending on this source,
the callback procedure is called.
.LP
The legal values for the condition argument are operating-system dependent.
On a UNIX-based system,
the condition is some union of
.PN XtInputReadMask ,
.PN XtInputWriteMask ,
and
.PN XtInputExceptMask .
.LP
Callback procedure pointers that are used when there are file events are of
type
.PN XtInputCallbackProc :
.IN "XtInputCallbackProc" "" "@DEF@"
.FD 0
typedef void (*XtInputCallbackProc)(caddr_t, int *, XtInputId *);
.br
	caddr_t \fIclient_data\fP;
.br
	int *\fIsource\fP;
.br
	XtInputId *\fIid\fP;
.FN
.IP \fIclient_data\fP 1i
Specifies the client data that was registered for this procedure in
.PN XtAppAddInput .
.IP \fIsource\fP 1i
Specifies the source file descriptor generating the event.
.IP \fIid\fP 1i
Specifies the ID returned from the corresponding
.PN XtAppAddInput
call.
.sp
.LP
To discontinue a source of input, use
.PN XtRemoveInput .
.IN "XtRemoveInput" "" "@DEF@"
.FD 0
void XtRemoveInput(\fIid\fP)
.br
      XtInputId \fIid\fP;
.FN
.IP \fIid\fP 1i
Specifies the ID returned from the corresponding
.PN XtAppAddInput
call.
.LP
The
.PN XtRemoveInput
function causes the \*(xI read routine to stop watching for input
from the input source.
.NH 3
Adding and Removing Timeouts
.XS
\fB\*(SN Adding and Removing Timeouts\fP
.XE
.LP
The timeout facility notifies the application or the widget
through a callback procedure that a specified time interval has elapsed.
Timeout values are uniquely identified by an interval ID.
.sp
.LP
To create a timeout value, use
.PN XtAppAddTimeOut .
.IN "XtAppAddTimeOut" "" "@DEF@"
.FD 0
XtIntervalId XtAppAddTimeOut(\fIapp_context\fP, \fIinterval\fP, \fIproc\fP, \
\fIclient_data\fP)
.br
      XtAppContext \fIapp_context\fP;
.br
      unsigned long \fIinterval\fP;
.br
      XtTimerCallbackProc \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.ds Co for which the timer is to be set
.IP \fIapp_context\fP 1i
Specifies the application context \*(Co.
.IP \fIinterval\fP 1i
Specifies the time interval in milliseconds.
.ds Pr \ to be called when the time expires
.IP \fIproc\fP 1i
Specifies the procedure that is\*(Pr.
.ds Cd it is called
.IP \fIclient_data\fP 1i
Specifies the argument that is to be passed to the specified procedure
when \*(Cd.
.LP
The
.PN XtAppAddTimeOut
function creates a timeout and returns an identifier for it.
The timeout value is set to interval.
The callback procedure is called when the time interval elapses,
and then the timeout is removed.
.LP
Callback procedure pointer that are used when timeouts expire are of
type
.PN XtTimerCallbackProc :
.IN "XtTimerCallbackProc" "" "@DEF@"
.FD 0
typedef void (*XtTimerCallbackProc)(caddr_t, XtIntervalId *);
.br
	caddr_t \fIclient_data\fP;
.br
	XtIntervalId *\fIid\fP;
.FN
.IP \fIclient_data\fP 1i
Specifies the client data that was registered for this procedure in
.PN XtAppAddTimeOut .
.IP \fIid\fP 1i
Specifies the ID returned from the corresponding
.PN XtAppAddTimeOut
call.
.sp
.LP
To clear a timeout value, use
.PN XtRemoveTimeOut .
.IN "XtRemoveTimeOut" "" "@DEF@"
.FD 0
void XtRemoveTimeOut(\fItimer\fP)
.br
      XtIntervalId \fItimer\fP;
.FN
.IP \fItimer\fP 1i
Specifies the ID for the timeout request to be destroyed.
.LP
The
.PN XtRemoveTimeOut
function removes the timeout.
Note that timeouts are automatically removed once they trigger.
.NH 2
Constraining Events to a Cascade of Widgets
.XS
\fB\*(SN Constraining Events to a Cascade of Widgets\fP
.XE
.LP
.IN "Grabbing Input"
.IN "Input Grabbing"
Modal widgets are widgets that, except for the input directly to them,
lock out user input to the application.
.LP
When a modal menu or modal dialog box is popped up using
.PN XtPopup ,
user events (keyboard and pointer events) that occur outside the modal
widget should be delivered to the modal widget or ignored.
In no case will user events be delivered to a widget outside
the modal widget.
.LP
Menus can pop up submenus and dialog boxes can pop up further dialog
boxes to create a pop-up cascade.
In this case,
user events may be delivered to one of several modal widgets in the cascade.
.LP
Display-related events should be delivered outside the modal cascade so that
expose events and the like keep the application's display up to date.
Any event that occurs within the cascade is delivered as usual.
The user events that are delivered to the most recent spring-loaded shell 
in the cascade when they occur outside the cascade are called remap events 
and are
.PN KeyPress ,
.PN KeyRelease ,
.PN ButtonPress ,
and
.PN ButtonRelease .
The user events that are ignored when they occur outside the cascade are
.PN MotionNotify ,
.PN EnterNotify ,
and
.PN LeaveNotify .
All other events are delivered normally.
.LP
.PN XtPopup
uses the 
.PN XtAddGrab
and
.PN XtRemoveGrab
functions to constrain user events to a modal cascade 
and subsequently to remove a grab when the modal widget goes away.
Usually you should have no need to call them explicitly.
.sp
.LP
To redirect user input to a modal widget, use
.PN XtAddGrab .
.IN "XtAddGrab" "" "@DEF@"
.FD 0
void XtAddGrab(\fIw\fP, \fIexclusive\fP, \fIspring_loaded\fP)
.br
      Widget \fIw\fP;
.br
      Boolean \fIexclusive\fP;
.br
      Boolean \fIspring_loaded\fP;
.FN
.ds Wi to add to the modal cascade
.IP \fIw\fP 1i
Specifies the widget \*(Wi.
.IP \fIexclusive\fP 1i
Specifies whether user events should be dispatched exclusively to this widget 
or also to previous widgets in the cascade.
.IP \fIspring_loaded\fP 1i
Specifies whether this widget was popped up because the user pressed
a pointer button.
.LP
The
.PN XtAddGrab
function appends the widget (and associated parameters) to the modal cascade
and checks that exclusive is 
.PN True 
if spring_loaded is 
.PN True .
If these are not 
.PN True , 
.PN XtAddGrab
generates an error.
.LP
The modal cascade is used by
.PN XtDispatchEvent
when it tries to dispatch a user event.
When at least one modal widget is in the widget cascade, 
.PN XtDispatchEvent
first determines if the event should be delivered.
It starts at the most recent cascade entry and follows the cascade up to and
including the most recent cascade entry added with the exclusive parameter
.PN True .
.LP
This subset of the modal cascade along with all descendants of these widgets
comprise the active subset.
User events that occur outside the widgets in this subset are ignored
or remapped.
Modal menus with submenus generally add a submenu widget to the cascade
with exclusive 
.PN False .
Modal dialog boxes that need to restrict user input to the most deeply nested
dialog box add a subdialog widget to the cascade with exclusive 
.PN True .
User events that occur within the active subset are delivered to the
appropriate widget, which is usually a child or further descendant of the modal
widget.
.LP
Regardless of where on the screen they occur,
remap events are always delivered to the most recent widget in the active
subset of the cascade that has spring_loaded 
.PN True ,
if any such widget exists.
.sp
.LP
To remove the redirection of user input to a modal widget, use
.PN XtRemoveGrab .
.IN "XtRemoveGrab" "" "@DEF@"
.FD 0
void XtRemoveGrab(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.ds Wi to remove from the modal cascade
.IP \fIw\fP 1i
Specifies the widget \*(Wi.
.LP
The
.PN XtRemoveGrab
function removes widgets from the modal cascade starting 
at the most recent widget up to and including the specified widget.
It issues an error if the specified widget is not on the modal cascade.
.NH 2
Focusing Events on a Child
.XS
\fB\*(SN Focusing Events on a Child\fP
.XE
.LP
To redirect keyboard input to a child of a 
.PN Composite 
widget without calling
.PN XSetInputFocus ,
use
.PN XtSetKeyboardFocus .
.IN "XtSetKeyboardFocus" "" "@DEF@"
.FD 0
XtSetKeyboardFocus(\fIsubtree\fP\, \fIdescendant\fP)
.br
     Widget \fIsubtree\fP, \fIdescendant\fP;
.FN
.IP \fIsubtree\fP 1i
Specifies the subtree of the hierarchy for which the keyboard focus is 
to be set.
.IP \fIdescendant\fP 1i
Specifies either the widget in the subtree structure which is to receive the 
keyboard event, or 
.PN None .
Note that it is not an error to specify
.PN None
when no input focus was previously set.
.LP
If a future 
.PN KeyPress
or
.PN KeyRelease 
event occurs within the specified subtree,
.PN XtSetKeyboardFocus
causes
.PN XtDispatchEvent
to remap and send the event to the specified descendant widget.
.LP
When there is no modal cascade,
keyboard events can occur within a widget W in one of three ways:
.IP \(bu 5
W has the X input focus.
.IP \(bu 5
W has the keyboard focus of one of its ancestors,
and the event occurs within the ancestor or one of the ancestor's descendants.
.IP \(bu 5
No ancestor of W has a descendant within the keyboard focus,
and the pointer is within W.
.LP
When there is a modal cascade,
a widget W receives keyboard events if an ancestor of W is in the active
subset of the modal cascade and one or more of the previous conditions is
.PN True .
.LP
When subtree or one of its descendants acquires the X input focus
or the pointer moves into the subtree such that keyboard events would
now be delivered to subtree, a
.PN FocusIn
event is generated for the descendant if
.PN FocusNotify
events have been selected by the descendant.
Similarly, when W loses the X input focus
or the keyboard focus for one of its ancestors, a
.PN FocusOut
event is generated for descendant if
.PN FocusNotify
events have been selected by the descendant.
.sp
.LP
.IN "accept_focus procedure"
The accept_focus procedure pointer is of type
.PN XtAcceptFocusProc :
.IN "XtAcceptFocusProc" ""@DEF@"
.FD 0
typedef Boolean (*XtAcceptFocusProc)(Widget, Time);
.br
        Widget \fIw\fP;
.br
        Time *\fItime\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fItime\fP 1i
Specifies the X time of the event causing the accept focus.
.LP
Widgets that need the input focus can call
.PN XSetInputFocus
explicitly.
To allow outside agents to cause a widget to get the input focus,
every widget exports an accept_focus procedure.
The widget returns whether it actually took the focus or not,
so that the parent can give the focus to another widget.
Widgets that need to know when they lose the input focus must use
the Xlib focus notification mechanism explicitly
(typically by specifying translations for
.PN FocusIn
and
.PN FocusOut
events).
Widgets that never want the input focus should set their
accept_focus procedure pointer to NULL.
.sp
.LP
To call a widget's accept_focus procedure, use
.PN XtCallAcceptFocus .
.IN "XtCallAcceptFocus" "" "@DEF@"
.FD 0
Boolean XtCallAcceptFocus(\fIw\fP, \fItime\fP)
.br
       Widget \fIw\fP;
.br
       Time *\fItime\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fItime\fP 1i
Specifies the X time of the event that is causing the accept focus.
.LP
The
.PN XtCallAcceptFocus
function calls the specified widget's accept_focus procedure,
passing it the specified widget and time, and returns what the accept_focus
procedure returns.
If accept_focus is NULL,
.PN XtCallAcceptFocus
returns
.PN False .
.NH 2
Querying Event Sources
.XS
\fB\*(SN Querying Event Sources\fP
.XE
.LP
The event manager provides several functions to examine and read events
(including file and timer events) that are in the queue.
The next three functions handle \*(xI equivalents of the
.PN XPending ,
.PN XPeekEvent ,
and
.PN XNextEvent
Xlib calls.
.sp
.LP
.IN "Events
To determine if there are any events on the input queue for a given application,
use
.PN XtAppPending .
.IN "XtAppPending" "" "@DEF@"
.FD 0
XtInputMask XtAppPending(\fIapp_context\fP)
.br
      XtAppContext \fIapp_context\fP;
.FN
.ds Co that identifies the application to check
.IP \fIapp_context\fP 1i
Specifies the application context \*(Co.
.LP
The
.PN XtAppPending
function returns a nonzero value if there are
events pending from the X server, timer pending, or other input sources
pending. The
value returned is a bit mask that is the OR of
.PN XtIMXEvent ,
.PN XtIMTimer ,
and
.PN XtIMAlternateInput
(see
.PN XtAppProcessEvent ).
If there are no events pending, 
.PN XtAppPending
flushes the output buffer and returns zero.
.sp
.LP
To return the value from the head of a given application's input queue
without removing input from the queue, use
.PN XtAppPeekEvent .
.IN "XtAppPeekEvent" "" "@DEF@"
.FD 0
Boolean XtAppPeekEvent(\fIapp_context\fP, \fIevent_return\fP)
.br
      XtAppContext \fIapp_context\fP;
.br
      XEvent *\fIevent_return\fP;
.FN
.ds Co that identifies the application
.IP \fIapp_context\fP 1i
Specifies the application context \*(Co.
.IP \fIevent_return\fP 1i
Returns the event information to the specified event structure.
.LP
If there is an event in the queue,
.PN XtAppPeekEvent
fills in the event and returns a nonzero value.
If no X input is on the queue,
.PN XtAppPeekEvent
flushes the output buffer and blocks until input is available
(possibly calling some timeout callbacks in the process).
If the input is an event,
.PN XtAppPeekEvent
fills in the event and returns a nonzero value.
Otherwise, the input is for an alternate input source, and
.PN XtAppPeekEvent
returns zero.
.sp
.LP
To return the value from the head of a given application's input queue,
use
.PN XtAppNextEvent .
.IN "XtAppNextEvent" "" "@DEF@"
.FD 0
void XtAppNextEvent(\fIapp_context\fP, \fIevent_return\fP)
.br
      XtAppContext \fIapp_context\fP;
.br
      XEvent *\fIevent_return\fP;
.FN
.ds Co that identifies the application
.IP \fIapp_context\fP 1i
Specifies the application context \*(Co.
.IP \fIevent_return\fP 1i
Returns the event information to the specified event structure.
.LP
If no input is on the X input queue,
.PN XtAppNextEvent
flushes the X output buffer
and waits for an event while looking at the other input sources
and timeout values and calling any callback procedures triggered by them.
This wait time can be used for background processing 
(see Section 7.8).
.NH 2
Dispatching Events
.XS
\fB\*(SN Dispatching Events\fP
.XE
.LP
The \*(xI provide functions that dispatch events
to widgets or other application code.
Every client interested in X events on a widget uses
.PN XtAddEventHandler
to register which events it is
interested in and a procedure (event handler) that is to be called
when the event happens in that window.
The translation manager automatically registers event handlers for widgets
that use translation tables (see Chapter 10).
.sp
.LP
Applications that need direct control of the processing of different types
of input should use
.PN XtAppProcessEvent .
.IN "XtAppProcessEvent" "" "@DEF@"
.FD 0
void XtAppProcessEvent(\fIapp_context\fP, \fImask\fP)
.br
      XtAppContext \fIapp_context\fP;
.br
      XtInputMask \fImask\fP;
.FN
.ds Co that identifies the application for which to process input
.IP \fIapp_context\fP 1i
Specifies the application context \*(Co.
.IP \fImask\fP 1i
Specifies what types of events to process.
The mask is the bitwise inclusive OR of any combination of
.PN XtIMXEvent ,
.PN XtIMTimer ,
and
.PN XtIMAlternateInput .
As a convenience, the \*(tk defines the symbolic name
.PN XtIMAll
to be the bitwise inclusive OR of all event types.
.LP
The
.PN XtAppProcessEvent
function processes one timer, alternate input, or X event.
If there is nothing of the appropriate type to process,
.PN XtAppProcessEvent
blocks until there is.
If there is more than one type of thing available to process,
it is undefined which will get processed.
Usually, this procedure is not called by client applications (see
.PN XtAppMainLoop ).
.PN XtAppProcessEvent
processes timer events by calling any appropriate timer callbacks, alternate
input by calling any appropriate alternate input callbacks, and X events by
calling
.PN XtDispatchEvent .
.LP
When an X event is received,
it is passed to
.PN XtDispatchEvent ,
which calls the appropriate event handlers
and passes them the widget, the event, and client-specific data
registered with each procedure.
If there are no handlers for that event registered,
the event is ignored and the dispatcher simply returns.
The order in which the handlers are called is undefined.
.sp
.LP
.IN "XtDispatchEvent" "" "@DEF@"
.FD 0
Boolean XtDispatchEvent(\fIevent\fP)
.br
      XEvent *\fIevent\fP;
.FN
.IP \fIevent\fP 1i
Specifies a pointer to the event structure that is to be dispatched
to the appropriate event handler.
.LP
The
.PN XtDispatchEvent
function sends those events to the event handler functions that
have been previously registered with the dispatch routine.
.PN XtDispatchEvent
returns 
.PN True 
if it dispatched the event to some handler and
.PN False
if it found no handler to dispatch the event to.
The most common use of
.PN XtDispatchEvent
is to dispatch events acquired with the
.PN XtAppNextEvent
procedure.
However, it also can be used to dispatch user-constructed events.
.PN XtDispatchEvent
also is responsible for implementing the grab semantics for
.PN XtAddGrab .
.NH 2
The Application Input Loop
.XS
\fB\*(SN The Application Input Loop\fP
.XE
.LP
To process input from a given application, use
.PN XtAppMainLoop .
.IN "XtAppMainLoop" "" "@DEF@"
.FD 0
void XtAppMainLoop(\fIapp_context\fP)
.br
      XtAppContext \fIapp_context\fP;
.FN
.ds Co that identifies the application
.IP \fIapp_context\fP 1i
Specifies the application context \*(Co.
.LP
The
.PN XtAppMainLoop
function first reads the next incoming X event by calling
.PN XtAppNextEvent 
and then it dispatches the event to the appropriate registered procedure 
by calling
.PN XtDispatchEvent .
This constitutes the main loop of \*(tk applications,
and, as such, it does not return.
Applications are expected to exit in response to some user action.
There is nothing special about
.PN XtAppMainLoop ;
it is simply an infinite loop that calls
.PN XtAppNextEvent
and then
.PN XtDispatchEvent .
.LP
Applications can provide their own version of this loop,
which tests some global termination flag or tests that the number
of top-level widgets is larger than zero before circling back to the call to
.PN XtAppNextEvent .
.NH 2
Setting and Checking the Sensitivity State of a Widget
.XS
\fB\*(SN Setting and Checking the Sensitivity State of a Widget\fP
.XE
.LP
Many widgets have a mode in which they assume a different appearance
(for example, are greyed out or stippled), do not respond to user events,
and become dormant.
.LP
When dormant,
a widget is considered to be insensitive.
If a widget is insensitive,
the Event Manager does not dispatch any events to the widget
with an event type of
.PN KeyPress ,
.PN KeyRelease ,
.PN ButtonPress ,
.PN ButtonRelease ,
.PN MotionNotify ,
.PN EnterNotify ,
.PN LeaveNotify ,
.PN FocusIn ,
or
.PN FocusOut .
.LP
A widget can be insensitive because its sensitive field is 
.PN False
or because one of its parents is insensitive, and, thus, the widget's
ancestor_sensitive field also is 
.PN False .
A widget can but does not need to distinguish these two cases visually.
.LP
To set the sensitivity state of a widget, use
.PN XtSetSensitive .
.IN "XtSetSensitive" "" "@DEF@"
.FD 0
void XtSetSensitive(\fIw\fP, \fIsensitive\fP)
.br
      Widget \fIw\fP;
.br
      Boolean \fIsensitive\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIsensitive\fP 1i
Specifies a Boolean value that indicates whether the widget should receive 
keyboard and pointer events.
.LP
The
.PN XtSetSensitive
function first calls
.PN XtSetValues
on the current widget with an argument list specifying that the
sensitive field should change to the new value.
It then recursively propagates the new value
down the managed children tree by calling
.PN XtSetValues
on each child to set the ancestor_sensitive to the new value if the new
values for sensitive and the child's ancestor_sensitive are not the same.
.LP
.PN XtSetSensitive
calls
.PN XtSetValues
to change sensitive and ancestor_sensitive.
Therefore, when one of these changes,
the widget's set_values procedure should
take whatever display actions are needed
(for example, greying out or stippling the widget).
.LP
.PN XtSetSensitive
maintains the invariant that if parent has either sensitive 
or ancestor_sensitive 
.PN False ,
then all children have ancestor_sensitive 
.PN False .
.sp
.LP
To check the current sensitivity state of a given widget 
(which is usually done by parents), use
.PN XtIsSensitive .
.IN "XtIsSensitive" "" "@DEF@"
.FD 0
Boolean XtIsSensitive(\fIw\fP)
.br
     Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
The
.PN XtIsSensitive
function returns 
.PN True 
or 
.PN False 
to indicate whether or not user input events are being dispatched.
If both core.sensitive and core.ancestor_sensitive are 
.PN True ,
.PN XtIsSensitive
returns 
.PN True ;
otherwise, it returns 
.PN False .
.NH 2
Adding Background Work Procedures
.XS
\fB\*(SN Adding Background Work Procedures\fP
.XE
.LP
The \*(xI have limited support for background processing.
Because most applications spend most of their time waiting for input, 
you can register an idle-time work procedure
that will be called when the toolkit would otherwise block in
.PN XtAppNextEvent
or
.PN XtAppProcessEvent .
Work procedure pointers are of type
.PN XtWorkProc :
.IN "XtWorkProc" "" "@DEF@"
.FD 0
typedef Boolean (*XtWorkProc)(caddr_t);
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIclient_data\fP 1i
Client data specified when the work proc was registered.
.LP
This procedure returns 
.PN True
if it is done, that is, the work procedure
should be removed.
Work procedures should be very judicious about how much they do. 
If they run for more than a small part of a second,
response time is likely to suffer.
.sp
.LP
To register a work procedure for a given application, use
.PN XtAppAddWorkProc .
.IN "XtAppAddWorkProc" "" "@DEF@"
.FD 0
XtWorkProcId XtAppAddWorkProc(\fIapp_context\fP, \fIproc\fP, \fIclient_data\fP)
.br
      XtAppContext \fIapp_context\fP;
.br
      XtWorkProc \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.ds Co that identifies the application
.IP \fIapp_context\fP 1i
Specifies the application context \*(Co.
.ds Pr \ to be called when the application is idle
.IP \fIproc\fP 1i
Specifies the procedure that is\*(Pr.
.ds Cd it is called
.IP \fIclient_data\fP 1i
Specifies the argument that is to be passed to the specified procedure
when \*(Cd.
.LP
The
.PN XtAppAddWorkProc
function adds the specified work procedure for the application identified
by app_context.
.LP
.PN XtWorkProcId
is an opaque unique identifier for this work procedure.
Multiple work procedures can be registered,
and the most recently added one is always the one that is called.
However, if a work procedure adds another work procedure, 
the newly added one has lower priority than the current one.
.sp
.LP
To remove a work procedure, either return 
.PN True 
from the procedure when it is called or use
.PN XtRemoveWorkProc .
.IN "XtRemoveWorkProc" "" "@DEF@"
.FD 0
void XtRemoveWorkProc(\fIid\fP)
.br
      XtWorkProcId \fIid\fP;
.FN
.IP \fIid\fP 1i
Specifies which work procedure to remove.
.LP
The
.PN XtRemoveWorkProc
function explicitly removes the specified background work procedure.
.NH 2
X Event Filters
.XS
\*(SN X Event Filters
.XE
.LP
The event manager provides filters that can be applied to X user events.
The filters, which screen out events that are redundant or are temporarily
unwanted, handle the following:
.IP \(bu 5
Pointer motion compression
.IP \(bu 5
Enter/leave compression
.IP \(bu 5
Exposure compression
.NH 3
Pointer Motion Compression
.XS
\*(SN Pointer Motion Compression
.XE
.LP
Widgets can have a hard time keeping up with pointer motion events.  Further,
they usually do not actually care about every motion event.  To throw out
redundant motion events, the widget class field compress_motion should be
.PN True .
.IN "compress_motion"
When a request for an event would return a motion event,
the \*(xI check if there are any other motion events immediately
following the current one, and, if so, skip all but the last of them.
.NH 3
Enter/Leave Compression
.XS
\*(SN Enter/Leave Compression
.XE
.LP
To throw out pairs of enter and leave events that have no intervening events,
as can happen when the user moves the pointer across a widget 
without stopping in it,
the widget class field compress_enterleave should be 
.PN True .
.IN "compress_enterleave"
These enter and leave events are not delivered to the client
if they are found together in the input queue.
.NH 3
Exposure Compression
.XS
\*(SN Exposure Compression
.XE
.LP
.IN "compress_expose field"
Many widgets prefer to process a series of exposure events as a
single expose region rather than as individual rectangles.  Widgets
with complex displays might use the expose region as a clip list
in a graphics context, and widgets with simple displays might
ignore the region entirely and redisplay their whole window or
might get the bounding box from the region and redisplay only that
rectangle.
.LP
In either case, these widgets do not care about getting partial expose events.
If the compress_exposure field in the widget class structure is 
.PN True ,
the event manager calls the widget's expose procedure only
once for each series of exposure events.
In this case, all
.PN Expose
events are accumulated into a region.
When the final 
.PN Expose
event in a series (that is, the one with count zero) is received,
the event manager replaces the rectangle in the event with the
bounding box for the region
and calls the widget's expose procedure,
passing the modified exposure event and the region.
(See \fI\*(xL\fP.)
.LP
If compress_exposure is 
.PN False , 
the event manager calls the widget's expose procedure for every exposure event,
passing it the event and a region argument of NULL.
.NH 2
Widget Exposure and Visibility
.XS
\*(SN Widget Exposure and Visibility
.XE
.LP
Every primitive widget and some composite widgets display data on the screen
by means of raw Xlib calls.
Widgets cannot simply write to the screen and forget what they have done.
They must keep enough state to redisplay the window or parts
of it if a portion is obscured and then reexposed.
.NH 3
Redisplay of a Widget: the expose Procedure
.XS
\*(SN Redisplay of a Widget: the expose Procedure
.XE
.IN "expose procedure"
.LP
The expose procedure pointer in a widget class is of type
.PN XtExposeProc :
.IN "XtExposeProc" "" "@DEF@"
.FD 0
typedef void (*XtExposeProc)(Widget, XEvent *, Region);
.br
      Widget \fIw\fP;
.br
      XEvent *\fIevent\fP;
.br
      Region \fIregion\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget instance requiring redisplay.
.IP \fIevent\fP 1i
Specifies the exposure event giving the rectangle requiring redisplay.
.IP \fIregion\fP 1i
Specifies the union of all rectangles in this exposure sequence.
.LP
The redisplay of a widget upon exposure is the responsibility of the
expose procedure in the widget's class record.
If a widget has no display semantics,
it can specify NULL for the expose field.
Many composite widgets serve only as containers for their children
and have no expose procedure.
.NT
If the expose procedure is NULL,
.PN XtRealizeWidget
fills in a default bit gravity of
.PN NorthWestGravity
before it calls the widget's realize procedure.
.NE
.LP
If the widget's compress_exposure class field is 
.PN False
(see Section 7.9.3),
region always is NULL.
If the widget's compress_exposure class field is 
.PN True , 
the event contains the bounding box for region.
.LP
A small simple widget (for example, Label) can ignore the bounding box
information in the event and redisplay the entire window.
A more complicated widget (for example, Text) can use the bounding box
information to minimize the amount of calculation and redisplay it does.
A very complex widget uses the region as a clip list in a GC and
ignores the event information.
The expose procedure is responsible for exposure of all superclass data
as well as its own.
.LP
However,
it often is possible to anticipate the display needs of several levels
of subclassing.
For example, rather than separate display procedures for
the widgets Label, Command, and Toggle,
you could write a single display routine in Label that uses display state
fields like the following:
.LP
.DS
Boolean invert
Boolean highlight
Dimension highlight_width
.DE
Label would have invert and highlight always 
.PN False
and highlight_width zero.
Command would dynamically set highlight and highlight_width, 
but it would leave invert always 
.PN False .
Finally, Toggle would dynamically set all three.
In this case,
the expose procedures for Command and Toggle inherit
their superclass's expose procedure.
For further information, see Section 1.4.9.
.NH 3
Widget Visibility
.XS
\*(SN Widget Visibility
.XE
.LP
Some widgets may use substantial computing resources to display data.
However, this effort is wasted if the widget is not actually visible
on the screen, that is, if the widget is obscured by another application 
or is iconified.
.LP
.IN "Visibility"
.IN "Visible"
The visible field in the
.PN Core
widget structure provides a hint to the widget that it need not display data.
This field is guaranteed 
.PN True
by the time an
.PN Expose
event is processed if the widget is visible
but is usually 
.PN False 
if the widget is not visible.
.LP
Widgets can use or ignore the visible hint.
If they ignore it,
they should have visible_interest in their widget class record set 
.PN False .
In such cases,
the visible field is initialized 
.PN True 
and never changes.
If visible_interest is 
.PN True ,
the event manager asks for
.PN VisibilityNotify
events for the widget and updates the visible field accordingly.
.NH 2
X Event Handlers
.XS
\*(SN X Event Handlers
.XE
.LP
Event handlers are procedures that are called when specified events
occur in a widget.
Most widgets need not use event handlers explicitly.
Instead, they use the \*(xI translation manager.
Event handler procedure pointers are of the type
.PN XtEventHandler :
.IN "XtEventHandler" "" "@DEF@"
.FD 0
typedef void (*XtEventHandler)(Widget, caddr_t, XEvent *);
.br
      Widget \fIw\fP;
.br
      caddr_t \fIclient_data\fP;
.br
      XEvent *\fIevent\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget for which to handle events.
.IP \fIclient_data\fP 1i
Specifies the client specific information registered with the event handler,
which is usually NULL if the event handler is registered by the widget itself.
.IP \fIevent\fP 1i
Specifies the triggering event.
.NH 3
Event Handlers that Select Events
.XS
\*(SN Event Handlers that Select Events
.XE
.LP
To register an event handler procedure with the dispatch mechanism, use
.PN XtAddEventHandler .
.IN "XtAddEventHandler" "" "@DEF@"
.FD 0
void XtAddEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      EventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.ds Wi for which this event handler is being registered
.IP \fIw\fP 1i
Specifies the widget \*(Wi.
.ds Em to call this procedure
.IP \fIevent_mask\fP 1i
Specifies the event mask for which \*(Em.
.ds Nm called
.IP \fInonmaskable\fP 1i
Specifies a Boolean value that indicates whether this procedure should be 
\*(Nm on the nonmaskable events
.Pn ( GraphicsExpose ,
.PN NoExpose ,
.PN SelectionClear ,
.PN SelectionRequest ,
.PN SelectionNotify ,
.PN ClientMessage ,
and
.PN MappingNotify ).
.ds Pr \ to be called
.IP \fIproc\fP 1i
Specifies the procedure that is\*(Pr.
.IP \fIclient_data\fP 1i
Specifies additional data to be passed to the client's event handler.
.LP
The
.PN XtAddEventHandler
function registers a procedure with the dispatch mechanism that is
to be called when an event that matches the mask occurs on the specified
widget.
If the procedure is already registered with the same client_data,
the specified mask is ORed into the existing mask.
If the widget is realized,
.PN XtAddEventHandler
calls
.PN XSelectInput ,
if necessary.
.sp
.LP
To remove a previously registered event handler, use
.PN XtRemoveEventHandler .
.IN "XtRemoveEventHandler" "" "@DEF@"
.FD 0
void XtRemoveEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      EventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.ds Wi for which this procedure is registered
.IP \fIw\fP 1i
Specifies the widget \*(Wi.
.ds Em to unregister this procedure
.IP \fIevent_mask\fP 1i
Specifies the event mask for which \*(Em.
.ds Nm removed
.IP \fInonmaskable\fP 1i
Specifies a Boolean value that indicates whether this procedure should be 
\*(Nm on the nonmaskable events
.Pn ( GraphicsExpose ,
.PN NoExpose ,
.PN SelectionClear ,
.PN SelectionRequest ,
.PN SelectionNotify ,
.PN ClientMessage ,
and
.PN MappingNotify ).
.ds Pr \ to be removed
.IP \fIproc\fP 1i
Specifies the procedure that is\*(Pr.
.IP \fIclient_data\fP 1i
Specifies the client data registered.
.LP
The
.PN XtRemoveEventHandler
function stops the specified procedure from receiving the specified events.
The request is ignored if client_data does not match the value given in the 
call to
.PN XtAddEventHandler .
If the widget is realized,
.PN XtRemoveEventHandler
calls
.PN XSelectInput ,
if necessary.
If the specified procedure has not been registered 
or if it has been registered with a different value of client_data,
.PN XtRemoveEventHandler
returns without reporting an error.
.LP
To stop a procedure from receiving any events, which will remove it from the
widget's event_table entirely, call
.PN XtRemoveEventHandler
with an event_mask of
.PN XtAllEvents
and with nonmaskable 
.PN True .
.NH 3
Event Handlers that Do Not Select Events
.XS
\*(SN Event Handlers that Do Not Select Events
.XE
.LP
On occasion,
clients need to register an event handler procedure with the
dispatch mechanism without causing the server to select for that event.
To do this, use
.PN XtAddRawEventHandler .
.IN "XtAddRawEventHandler" "" "@DEF@"
.FD 0
void XtAddRawEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      EventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.ds Wi for which this event handler is being registered
.IP \fIw\fP 1i
Specifies the widget \*(Wi.
.ds Em to call this procedure
.IP \fIevent_mask\fP 1i
Specifies the event mask for which \*(Em.
.IP \fInonmaskable\fP 1i
Specifies a Boolean value that indicates whether this procedure should be 
\*(Nm on the nonmaskable events
.Pn ( GraphicsExpose ,
.PN NoExpose ,
.PN SelectionClear ,
.PN SelectionRequest ,
.PN SelectionNotify ,
.PN ClientMessage ,
and
.PN MappingNotify ).
.ds Pr \ to be registered
.IP \fIproc\fP 1i
Specifies the procedure that is\*(Pr.
.IP \fIclient_data\fP 1i
Specifies additional data to be passed to the client's event handler.
.LP
The
.PN XtAddRawEventHandler
function is similar to
.PN XtAddEventHandler 
except that it does not affect the widget's mask and never causes an
.PN XSelectInput
for its events.
Note that the widget might already have those mask bits set
because of other nonraw event handlers registered on it.
.sp
.LP
To remove a previously registered raw event handler, use
.PN XtRemoveRawEventHandler .
.IN "XtRemoveRawEventHandler" "" "@DEF@"
.FD 0
void XtRemoveRawEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      EventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.ds Wi for which this procedure is registered
.IP \fIw\fP 1i
Specifies the widget \*(Wi.
.ds Em to unregister this procedure
.IP \fIevent_mask\fP 1i
Specifies the event mask for which \*(Em.
.ds Nm removed
.IP \fInonmaskable\fP 1i
Specifies a Boolean value that indicates whether this procedure should be 
\*(Nm on the nonmaskable events
.Pn ( GraphicsExpose ,
.PN NoExpose ,
.PN SelectionClear ,
.PN SelectionRequest ,
.PN SelectionNotify ,
.PN ClientMessage ,
and
.PN MappingNotify ).
.ds Pr \ to be registered
.IP \fIproc\fP 1i
Specifies the procedure that is\*(Pr.
.IP \fIclient_data\fP 1i
Specifies the client data registered.
.LP
The
.PN XtRemoveRawEventHandler
function stops the specified procedure from receiving the specified events.
Because the procedure is a raw event handler,
this does not affect the widget's mask and never causes a call on
.PN XSelectInput .
.NH 3
Current Event Mask
.XS
\*(SN Current Event Mask
.XE
.LP
To retrieve the event mask for a given widget, use
.PN XtBuildEventMask .
.IN "XtBuildEventMask" "" "@DEF@"
.FD 0
EventMask XtBuildEventMask(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
The
.PN XtBuildEventMask
function returns the event mask representing the logical OR
of all event masks for event handlers registered on the widget with
.PN XtAddEventHandler
and all event translations, including accelerators,
installed on the widget.
This is the same event mask stored into the 
.PN XSetWindowAttributes
structure by
.PN XtRealizeWidget
and sent to the server when event handlers and translations are installed or
removed on the realized widget.
.bp
