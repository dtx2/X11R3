



                        X11 Server Extensions




-------------------------------------------------------------------

PUBLIC SPECIFICATION          18-February-1987
Update for Beta Test           1-June-1987 (BF)
Update for final release      28-August-1987 (RS,RD,BF)

TITLE         X11 Server Extensions Engineering Specification

AUTHOR:       Burns Fisher (Digital Equipment Corporation)

CONTRIBUTERS: (Digital Equipment Corp unless otherwise noted)
              Susan Angebranndt
              David Carver
              Colyn Case
              Raymond Drewry
              Todd Newman
              Phil Karlton
              Pam Levesque
              Bill Matthews
              Robin Schaufler (Sun MicroSystems)
-------------------------------------------------------------------


This document describes the  interface  between  the  MIT  X11  Sample
Server and portable extensions.



                                                                Page 2


                                   CONTENTS

        1       INTRODUCTION AND OVERVIEW  . . . . . . . . . . . . . 4
        1.1       Definitions  . . . . . . . . . . . . . . . . . . . 4
        1.2       Extensions Versus Device Support . . . . . . . . . 4
        1.3       Scope Of Extensions  . . . . . . . . . . . . . . . 5
        1.4       Assumptions  . . . . . . . . . . . . . . . . . . . 6
        1.5       Portable Extension Capabilities  . . . . . . . . . 6
        1.5.1     GC Interactions  . . . . . . . . . . . . . . . . . 6
        1.5.2     Calling Output Routines Through The GC . . . . . . 7
        1.5.3     Input Extensions . . . . . . . . . . . . . . . . . 7
        1.5.4     Extension Requests . . . . . . . . . . . . . . . . 7
        1.5.5     Replies  . . . . . . . . . . . . . . . . . . . . . 7
        1.5.6     Errors . . . . . . . . . . . . . . . . . . . . . . 7
        1.5.7     Resources  . . . . . . . . . . . . . . . . . . . . 8
        1.5.8     Atoms  . . . . . . . . . . . . . . . . . . . . . . 8
        1.5.9     Initialization . . . . . . . . . . . . . . . . . . 8
        1.5.10    Extended Functions . . . . . . . . . . . . . . . . 8
        2       GC INTERACTIONS  . . . . . . . . . . . . . . . . . . 8
        2.1       The GC Data Structure  . . . . . . . . . . . . . . 8
        2.2       The GCInterest Data Structure  . . . . . . . . . . 9
        2.3       Interfacing To The GC By Extensions And Device 
                  Support Routines . . . . . . . . . . . . . . . . . 9
        2.3.1     Expressing Interest  . . . . . . . . . . . . . . . 9
        2.3.2     Modifying A GC . . . . . . . . . . . . . . . . .  14
        2.3.3     Reading Or Calling Through A GC  . . . . . . . .  14
        2.3.4     Interface Routines . . . . . . . . . . . . . . .  14
        3       CALLING OUTPUT ROUTINES THROUGH THE GC . . . . . .  17
        4       INPUT  . . . . . . . . . . . . . . . . . . . . . .  20
        4.1       Input Extension Sequence Of Events . . . . . . .  20
        4.2       Cause A Device To Be Grabbed Or UnGrabbed  . . .  22
        4.3       Associate A Device With A Window . . . . . . . .  22
        4.4       Intercept Input From The System Devices Or Other 
                  Extensions . . . . . . . . . . . . . . . . . . .  22
        4.5       Getting An Event Mask  . . . . . . . . . . . . .  23
        4.6       Polling For Input  . . . . . . . . . . . . . . .  23
        5       EXTENSION REQUESTS . . . . . . . . . . . . . . . .  24
        5.1       Additional Utility Functions Available . . . . .  24
        5.1.1     REQUEST(RequestStructure)  . . . . . . . . . . .  25
        5.1.2     REQUEST_SIZE_MATCH(RequestStructure) . . . . . .  25
        5.1.3     REQUEST_AT_LEAST_SIZE(RequestStructure)  . . . .  25
        6       EXTENSION-GENERATED REPLIES  . . . . . . . . . . .  25
        7       EXTENSION-GENERATED ERRORS . . . . . . . . . . . .  25
        8       RESOURCES  . . . . . . . . . . . . . . . . . . . .  26
        9       ATOMS  . . . . . . . . . . . . . . . . . . . . . .  28
        10      LOADING AND INITIALIZATION . . . . . . . . . . . .  29
        10.1      Making The Extension Known To The Server . . . .  29
        10.2      Making Event Swappers Known To The Server  . . .  31
        10.3      Linked In Extensions . . . . . . . . . . . . . .  31
        10.4      Dynamically Loaded Extensions  . . . . . . . . .  31
        11      EXTENDED FUNCTIONS . . . . . . . . . . . . . . . .  32

                                                                Page 3


APPENDIX A      EXPOSED STRUCTURES

        A.1     GC (GRAPHIC CONTEXT) . . . . . . . . . . . . . . . A-1
        A.2     GCINTEREST . . . . . . . . . . . . . . . . . . . . A-1
        A.3     CLIENT . . . . . . . . . . . . . . . . . . . . . . A-2
        A.4     DRAWABLE . . . . . . . . . . . . . . . . . . . . . A-2
        A.5     PIXMAP . . . . . . . . . . . . . . . . . . . . . . A-3
        A.6     DEVICE . . . . . . . . . . . . . . . . . . . . . . A-3
        A.7     XEVENTS  . . . . . . . . . . . . . . . . . . . . . A-3
        A.8     GRAB . . . . . . . . . . . . . . . . . . . . . . . A-3
        A.9     EXTENSIONENTRY . . . . . . . . . . . . . . . . . . A-4
        A.10    XSEGMENT . . . . . . . . . . . . . . . . . . . . . A-4
        A.11    XPOINT . . . . . . . . . . . . . . . . . . . . . . A-4
        A.12    DDXPOINT . . . . . . . . . . . . . . . . . . . . . A-4
        A.13    XRECTANGLE . . . . . . . . . . . . . . . . . . . . A-5
        A.14    XARC . . . . . . . . . . . . . . . . . . . . . . . A-5
        A.15    CHARINFOPTR  . . . . . . . . . . . . . . . . . . . A-5
        A.16    POINTER  . . . . . . . . . . . . . . . . . . . . . A-5


APPENDIX B      ROUTINES AVAILABLE TO PORTABLE EXTENSIONS


APPENDIX C      CONSTANTS AVAILABLE TO PORTABLE EXTENSIONS


APPENDIX D      INCLUDE FILES AVAILABLE TO PORTABLE EXTENSIONS


APPENDIX E      ZOID--A SAMPLE EXTENSION IMPLEMENTATION

        E.1          INTRODUCTION  . . . . . . . . . . . . . . . . E-1
        E.2     THEORY OF OPERATION  . . . . . . . . . . . . . . . E-2
        E.3     CODE (ZOID.C)  . . . . . . . . . . . . . . . . . . E-3
        E.4     CODE (ZOID.H)  . . . . . . . . . . . . . . . . .  E-10

X11 Server Extension                                            Page 4
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  1  INTRODUCTION AND OVERVIEW


  This document is the specification for the  extension  interface  to
  the   MIT  X11  sample  server.   Our  purpose  in  developing  this
  specification is  to  provide  a  mechanism  general  enough  to  be
  supplied  with the generic MIT sample server, but powerful enough so
  that it could be adopted by the X community as an  ad  hoc  standard
  interface.   Standardization  will allow the development of portable
  extensions, which will greatly benefit the X community.




  1.1  Definitions


   o  Core:  Relating to the X11 protocol as  currently  defined;  not
      related to extensions.  Examples:  Core Server--The parts of the
      server that deal with the unextended X11 protocol.

   o  DD:  Device Dependent

   o  DI:  Device Independent

   o  Device Support:  The code which is added to a server to  support
      a  particular  input  device  or screen.  Device support usually
      implies core device support in this document, although  in  real
      life,  adding  a new input device might require adding extension
      code as well.  Device support is also called DDX.

   o  Extension:  Code which can (1) add new requests  to  the  server
      and (2) make core requests behave in new ways.

   o  Portable Extension:  An extension which is likely to be portable
      among many servers and devices.

   o  Nonportable or Dependent Extension:  An extension which  depends
      on  a  particular  server implementation or a particular device.
      Typically, non-portable extensions have portable parts  in  much
      the same way the core server is divided into diX and ddX.




  1.2  Extensions Versus Device Support


  Although, at first glance, extensions and device support may seem to
  be  totally different, both have very similar requirements.  In many
  cases the mechanisms that are provided for extensions are  the  same
  mechanisms which are used by device support.

  Although this document specifies the extension  interface,  in  many

X11 Server Extension                                            Page 5
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  cases  it  discusses  device  support,  simply  because  the two are
  intertwined so tightly that both must be  discussed  to  supply  the
  correct context.  In addition, this document will often mention "the
  extension or device support routines" to emphasize that  both  types
  of code use the feature being discussed.




  1.3  Scope Of Extensions


  One can divide output extensions into two groups.  One group,  which
  could  be  called  non-portable  extensions, performs completely new
  functions which are closely coupled with the hardware.  Examples  of
  these  extensions  might  be  real  time  rotation  on  a  high  end
  workstation, or perhaps text rotation on a workstation with hardware
  text rotation support.

  The other group, which we could  call  portable  extensions,  either
  modifies existing functions or implements new but layered functions.
  Examples of an  independent  extension  could  be  a  curve  drawing
  extension,  a  world coordinate package, server-based display lists,
  or extensions which perform combinations of standard  X  calls  (for
  example DrawICPad).

  The interface specified in this document serves two major purposes.

  1.  It defines a  method  for  all  extensions  to  connect  to  and
      interact  with important parts of the server without interfering
      with each other

  2.  It defines the limits on what a portable extension can do

  In other words, any extension can  connect  into  the  server  using
  these  mechanisms and be guaranteed of a controlled interaction with
  other extensions.  If the  extension  does  not  do  anything  which
  depends  on interfaces that are not specified here, it can be ported
  to any server which supports this spec, without necessarilly  having
  access to the server source code.

  If an extension must work closely with hardware, then it  must  have
  knowledge  of  either  the  core  device  support  code,  or  of the
  operating  system  I/O  interface  or  both.   Since  this   implies
  interactions  which  are  not  specified  in  this  document,  these
  extensions must be  non-portable,  or  dependent.   Similarly,  some
  extensions may choose to interact with the core server in ways which
  are not defined in this document.  They too must be dependent.

  Some extensions may be implemented  portably,  but  may  have  their
  performance  enhanced  in non-portable implementations.  A method of
  registering the existence of a procedure is provided, so that if the
  hardware   supports   an   extension,   and   a  hardware  dependent
  implementation exists, it may be registered.  A portable version  of

X11 Server Extension                                            Page 6
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  the   extension  may  be  developed  separately,  which  checks  for
  existence of a hardware dependent accelerator, using  it  if  it  is
  present, and going through portable interfaces if it is not.



  1.4  Assumptions


  Readers are assumed to be familiar with the X11 MIT  Sample  server.
  In particular, they are assumed to understand the general concept of
  a graphic context, and the specific implementation of GC vectors  in
  the MIT Sample server.

  A primary assumption is that the primary hooks that portable  output
  extensions  have  into the server are GCs.  An extension is expected
  to keep its context connected to a GC, and the main influences  that
  it can have on the server are by changing the contents of GCs and by
  being notified when GCs are changed.

  A few implications of this assumption are that an extension must  be
  explicitly  activated (simply loading it via QueryExtension does not
  activate it because it does not get a GC at that time)  and  that  a
  portable  output  extension  cannot  affect operations of the server
  which do not involve GCs.  (For example, a portable output extension
  cannot  modify the action of the OpenFont request, although it could
  modify PolyLine.)



  1.5  Portable Extension Capabilities

  This section describes the general capabilities which  the  standard
  extension  interface  supplies.   Each capability is expanded in the
  following chapters.



  1.5.1  GC Interactions -

  A portable extension can arrange  to  be  called  when  any  of  the
  following things happen

  1.  A particular GC is modified by any of the following X requests:

       o  ChangeGC

       o  CopyGC

       o  SetClipRectangles

       o  SetDashes

X11 Server Extension                                            Page 7
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


       o  FreeGC


  2.  A particular GC is about to be used by a  drawing  request,  and
      any of the following things are true:

       o  The GC has been changed since the last time it was used

       o  The cliplist of the drawable which  will  be  drawn  to  has
          changed  since the last time the drawable was used with this
          GC


  A portable  extension  may  replace  entries  in  the  GC  procedure
  vectors.  Since these procedure vectors are used to call routines to
  do the drawing, this means that a portable extension  may  intercept
  calls to the drawing routines.



  1.5.2  Calling Output Routines Through The GC -

  A portable extension may call through  a  GC  vector  to  cause  the
  drawing routine to do output.



  1.5.3  Input Extensions -

  Input extensions can also be classified as portable or non-portable.
  A  dependent input extension will provide support for a non-standard
  input device.  A portable extension can  intercept  input  from  any
  device  (core or non-standard), or provide services not specified in
  the core protocol.




  1.5.4  Extension Requests -

  A portable extension may receive extension requests from the client.



  1.5.5  Replies -

  A portable extension may send replies to the client.



  1.5.6  Errors -

  A portable extension may send errors to the client.

X11 Server Extension                                            Page 8
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  1.5.7  Resources -

  A portable extension may create new resources, resource  types,  and
  resource  classses.   Class  allow a portable extension to store and
  retrieve additional data with core resources.



  1.5.8  Atoms -

  A portable extension may create and look up Atoms.  (Atoms  may  not
  be deleted.  They remain until the server resets.)



  1.5.9  Initialization -

  A portable extension must provide an  initialization  routine  which
  will be called when the extension is loaded.



  1.5.10  Extended  Functions - The  extension  interface  provides  a
  mechanism  whereby  an  extension  may determine whether an expanded
  capability (for example FillTrapezoid) exists on the server.



  2  GC INTERACTIONS

  2.1  The GC Data Structure


  The GC is a data structure which corresponds to the GC resource that
  a client uses.  It is where all the information that the client sets
  into a GC is stored.  However, it  performs  another  function:   it
  keeps the context that the server will use to do output when that GC
  is specified.  In  particular,  it  contains  a  vector  of  routine
  pointers  which  the  server  uses  to do different kinds of drawing
  functions.  For example, there is a pointer to a routine  which  the
  server  will  use  to  draw  polylines.  The routine that this entry
  points at may change depending on whether the  GC  is  set  to  draw
  narrow, wide, or dashed lines.

  An extension can specify a list of entry points to be called when  a
  particular  GC  is  modified  or  deleted.   The  extension can also
  specify an entry point to be called when the GC is  validated,  just
  prior  to  a drawing operation.  When it does this, it indicates for
  which state changes it wishes to be called.

  When a client request is processed which results in a change to  the
  GC,  the  device  independent  state  of  the  GC  is updated.  This
  includes a record of which parts of the state were changed.  If  the
  extension   has  requested  notification  of  GC  modification,  the

X11 Server Extension                                            Page 9
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  specified entry point  is  called.   This  is  useful  for  graphics
  sub-systems which are able to process state changes in parallel with
  the server cpu.  The extension may opt not to  take  any  action  at
  GC-modify  time.   This  is  more  efficient  if  multiple GC-modify
  requests occur between draws using a given GC.

  Validation occurs at the first draw operation which specifies the GC
  after  that GC was modified.  If there are state-changes in which an
  extension has expresed interest, the extension's validation  routine
  is called.  The extension then updates its internal state.

  Extension internal state may  be  stored  as  one  or  more  of  the
  following:   1)  Device  private  block  on the GCInterest structure
  (defined in the next section) 2) Hardware state; 3) Changes  to  the
  GC vectors.

  The extension can create a state change which will force  validation
  on  the  next  draw  operation.   This  is done by setting a special
  extension state change bit called GCExtensionInterest  <gc.h>  using
  the routine SetGCMask as described below.




  2.2  The GCInterest Data Structure


  A GCInterest is a data structure created by an extension for each GC
  that  the  extension  wishes to express interest in.  The GCInterest
  defines what extension is  interested,  and  what  routines  in  the
  extension should be called for each of several changes that might be
  made to a GC.



  2.3  Interfacing To The GC By Extensions And Device Support Routines


  The following  sections  discuss  specifically  how  extensions  and
  devices express interest in, modify, and use GCs.



  2.3.1  Expressing Interest -

  Expressing interest means that a device or extension  says  that  it
  wishes to be notified when certain changes affecting a particular GC
  happen.  An extension expresses  interest  in  a  GC  by  linking  a
  GCInterest  data structure into a queue whose header is in the GC of
  interest.  The GCInterest  tells  which  changes  the  extension  is
  interested in, and what routine to call if that change happens.

  An extension can express interest in the following GC changes:

X11 Server Extension                                           Page 10
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  1.  ChangeGC

  2.  ValidateGC

  3.  CopyGC (Source)

  4.  CopyGC (Destination)

  5.  FreeGC

  In the case of ChangeGC and ValidateGC, the extension must set up  a
  StateChange  mask  in the GCInterest structure.  This mask is in the
  same format  as  the  GC  StateChange  mask.   For  validation,  the
  extension  will  only  be notified if the boolean AND of the GC mask
  and the GCInterest mask is non-zero.  For  ChangeGC,  the  extension
  will  be  called only if the boolean AND of the value mask sent with
  the ChangeGC request and the GCInterest mask is non-zero.

  An extension expresses interest in a particular  change  by  placing
  the  address of a routine in the corresponding GCInterest field.  If
  the extension is not interested in  that  change  the  corresponding
  field  must be set to 0 for the case of CopyGCSource, CopyGCDest, or
  DestroyGC.  For ChangeGC and ValidateGC, the interest  mask  in  the
  GCInterest  should  be  set to 0.  The following list describes what
  changes the extension can express interest in, what  vector  in  the
  GCInterest  it  uses  to do so, and what arguments will be passed to
  the extension when that change happens.

   o  GC Is Validated (Vector:  ValidateGC)

      In this case,  the  extension  or  device  gets  to  specify  in
      addition  which particular values in the GC it is interested in.
      If any of these values have been changed since the last time the
      GC  was validated, the extension will be notified.  Otherwise it
      will not.

      Arguments:

        GC        !Pointer to the GC being validated
        GCInterest!Pointer to the GCInterest that caused this routine
                        !to be called
        Mask      !The GC mask telling what things have changed
        DRAWABLE  !The drawable being used for the drawing routine that
                  !caused the validate

      Note:  Besides the GC values that are specified  in  a  ChangeGC
      value mask, the extension can also use the GCWindowChange bit to
      express interest in a change in the the window clip list, or the
      GCExtensionInterest  bit to express interest in the fact that an
      extension has declared the GC invalid.

   o  Change GC (Vector:  ChangeGC)

      In this case,  the  extension  or  device  gets  to  specify  in

X11 Server Extension                                           Page 11
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


      addition  which particular values in the GC it is interested in.
      The routine is called when the GC is the object of  one  of  the
      requests  ChangeGC,  SetClipRectangles,  or  SetDashes.  The bit
      used to express interest in SetClipRectangles is the same as the
      GC  value  mask bit for setting a clipping pixmap.  The bit used
      to express interest in SetDashes is the same  as  the  GC  value
      mask bit for setting a simple dash pattern.

      Arguments:

        GC        !Pointer to the GC being changed
        GCInterest!Pointer to the GCInterest that caused this routine
                        !to be called
        MASK      !Pointer to the value mask(s) for the change

   o  Copy GC (Vector:  CopyGCSource)

      This GC is the source of a CopyGC request.

      Arguments:

        GC        !Pointer to the GC being copied from
        GCInterest!Pointer to the GCInterest that caused this routine
                        !to be called
        MASK      !Pointer to the value mask(s) for the copy
        DEST_GC   !Pointer to the destination GC

   o  Copy GC (Vector:  CopyGCDest)

      This GC is the destination of a CopyGC request.

      Arguments:

        GC        !Pointer to the GC copied to
        GCInterest!Pointer to the GCInterest that caused this routine
                        !to be called
        MASK      !Pointer to the value mask(s) for the copy
        SRC_GC    !Pointer to the source GC

   o  Destroy GC (Vector:  DestroyGC)

      This GC is no longer needed,  and  will  be  deleted  after  all
      extensions  have  been  notified.   The  extension  may  express
      interest in GC  deletion  in  order  to  remove  its  GCInterest
      structures from the queue and deallocate or cache them.  If they
      are not removed and if the extension is not keeping a pointer to
      them, they will be left hanging when the GC is deleted.

      Arguments:

        GC        !Pointer to the GC being validated
        GCInterest!Pointer to the GCInterest that caused this routine
                        !to be called

X11 Server Extension                                           Page 12
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  Also, note that the above routines are all called AFTER the DI  part
  of  the  GC  has  been  modified  in  the  manner  specified  by the
  particular call, with two exceptions.  For Destroy, the  GC  is  not
  actually  deallocated  until  after all the GCInterest routines have
  been called.  For VALIDATE, the  StateChanges  mask  in  the  GC  is
  cleared after all the GCInterest routines have been called.


       Possible values for the StateChanges mask are:

       GCFunction

       GCPlaneMask

       GCForeground

       GCBackground

       GCLineWidth

       GCLineStyle

       GCCapStyle

       GCJoinStyle

       GCFillStyle

       GCFillRule

       GCTile

       GCStipple

       GCTileStipXOrigin

       GCTileStipYOrigin

       GCFont

       GCSubwindowMode

       GCGraphicsExposures

       GCClipXOrigin

       GCClipYOrigin

       GCClipMask

       GCDashOffset

       GCDashList

X11 Server Extension                                           Page 13
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


       GCArcMode

       GCExtensionInterest

  An extension or device expresses interest in a  GC  by  attaching  a
  GCInterest  structure  to  a  queue  whose header is in the GC.  The
  extension does the insertion by using the routine InsertGCI (defined
  below).  The GCInterest may be attached any place in the queue.  The
  order in the queue determines the order that routines will be called
  when the change happens.

  A GCInterest structure is placed in the queue  using  the  following
  routine:

        void InsertGCI(pGC,pGCI,order,pPrevGCI)

                GC  *pGC
                GCI  *pGCI
                int order
                GCI *pPrevGCI

  Where order may be one of the constants

                GCI_FIRST 
                GCI_LAST
                GCI_MIDDLE

  If order is either GCI_FIRST or GCI_LAST, the  GCInterest  specified
  by  pGCI  is  placed  respectively  first  or last on the queue, and
  pPrevGCI is ignored.  If order is  GCI_MIDDLE,  then  the  specified
  GCInterest is placed immediately following PrevGCI.

  A GCInterest structure is removed from the queue using the following
  routine:

        void RemoveGCI(pGCI)

                GCI  *pGCI


  The ID field of each GCInterest contains either 0 if the  GCInterest
  is  owned by core device support routines, or an atom containing the
  name of the extension which owns  it.   Cooperating  extensions  may
  look at these ID fields to find GCInterest structures owned by their
  partners.  Any extension may identify the core GCInterest  structure
  by looking for an ID of 0.

  The EXT_PRIVATE field may be used by the GCInterest  owner  for  any
  purpose.  One possible use might be to point at an extension-private
  GC which is used by the extension to hold new GC attributes  defined
  by the extension.

  Note that device support routines are not treated in any special way
  when  a GC gets validated.  In order to insure that they are called,

X11 Server Extension                                           Page 14
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  they must attach a GCInterest to each new GC when it is created.

  The GCInterest structure is defined in section 12.



  2.3.2  Modifying A GC -

  Extensions and device support routines must modify GCs in  order  to
  reflect  changes  that  have  been  requested  by  the  client.   In
  particular, they must set the call vectors and the StateChanges mask
  to reflect the GC state.

  Two routines are provided  for  writing  to  the  GC.   Call  vector
  elements  must  be  modified  using  the  routine  SetGCVector.  The
  StateChange mask can be modified using the routine SetGCMask.




  2.3.3  Reading Or Calling Through A GC -

  In order to read or call through the GC, you must  use  the  routine
  GetGCValue, defined below.



  2.3.4  Interface Routines -

   o  SetGCMask(GC,selectMask,newDataMask)

      This routine replaces the GC StateChanges mask  with  data  from
      newDataMask  in the following way.  For each bit which is set in
      selectMask, the corresponding bit is  written  from  newDataMask
      into the GC StateChanges mask.  In other words, selectMask tells
      which bits to change, while newDataMask  tells  what  value  the
      changed bits should be.

      The modified mask value will be used to compare with  any  other
      GCInterest  structures  which need to be examined in the current
      validation.  The extension must use  this  routine  rather  than
      writing  directly  into  the  GC,  to insure that the validation
      routine gets an updated mask  to  compare  with.   There  is  no
      guarantee  that the validation routine will actually look at the
      GC StateChanges mask itself for each GCInterest.

   o  SetGCVector(pGC,VectorElement,NewRoutineAddress,ExtensionAtom)

        GC  *pGC           /* A pointer to the GC to be modified*/
        int VectorElement /*A constant indicating which vector
                            element to replace*/
        void (*NewRoutineAddress)()
        Atom ExtensionAtom /* An atom containing the name of the
                                extension*/

X11 Server Extension                                           Page 15
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987



      This routine is used  to  replace  the  procedure  vector  entry
      specified  by  VectorElement  in  the  GC pointed at by pGC with
      NewRoutineAddress.   ExtensionAtom  identifies   the   extension
      making the replacement.  Allowed values for VectorElement are:

       -  FillSpans

       -  SetSpans

       -  GetSpans

       -  PutImage

       -  CopyArea

       -  CopyPlane

       -  PolyPoint

       -  Polylines

       -  PolySegment

       -  PolyRectangle

       -  PolyArc

       -  FillPolygon

       -  PolyFillRect

       -  PolyFillArc

       -  PolyText8

       -  PolyText16

       -  ImageText8

       -  ImageText16

       -  ImageGlyphBlt

       -  PolyGlyphBlt

       -  PushPixels

       -  GetImage

       -  QueryTextExtents

      Notice that you must use these names  and  no  others  (even  if
      another  name has been defined to have the same value).  This is

X11 Server Extension                                           Page 16
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


      because some servers and language bindings  may  implement  this
      routine  as a macro which will use the text of the name that you
      supply for VectorElement rather than the name's value.

   o  int GetGCValue(pGC,VectorElement)

      This routine  returns  the  contents  of  the  specified  vector
      element.   The  extension  writer is responsible for making sure
      that the compiler does no type changing on the return value from
      GetGCVector.   In  the  C  language,  this  would  be  done with
      typecasting.  For example

        unsigned long currentPlaneMask
                ...
        currentPlaneMask = (unsigned long)GetGCValue(pGC,planemask);

      Legal values for GCElement are the same as those for SetGCVector
      plus  the  following  (types  of  the  data  follow  the name in
      parentheses):

       -  depth (int)

       -  alu (int)

       -  planemask (unsigned long)

       -  fgPixel ( unsigned long)

       -  bgPixel ( unsigned long)

       -  lineWidth ( int)

       -  lineStyle (int)

       -  capStyle (int)

       -  joinStyle (int)

       -  fillStyle (int)

       -  fillRule (int)

       -  arcMode (int)

       -  patOrg (DDXPointRec)     /*   origin   for   patterns    (tile,
          stipple)*/

       -  subWindowMode (int)

       -  clipOrg (DDXPointRec)

       -  clientClipType (int)

X11 Server Extension                                           Page 17
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


       -  dashOffset (int)

       -  *dash (unsigned char *)





  3  CALLING OUTPUT ROUTINES THROUGH THE GC

  An extension may call through any vector  in  any  valid  GC,  using
  GetGCValue.  For example,

  (*GetGCValue(pGC,FillPolygon))(pDraw,pGC,buffer);

  Below is a description of the arguments each GC function  takes  and
  its return value type.

      void FillSpans (pDraw, pGC, nInit, pptInit, pwidthInit, fSorted)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         nInit;              /* number of spans to fill */
        xPoint      *pptInit;           /* pointer to list of start points */
        int         *pwidthInit;        /* pointer to list of n widths */
        int         fSorted;

      void SetSpans (pDraw, pGC, psrc, ppt, pwidth, nspans, fSorted)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         *psrc;
        xPoint      *ppt;
        int         *pwidth;
        int         nspans;
        int         fSorted;

      void PutImage (pDraw, pGC, depth, x, y, w, h, leftPad, format, pImage)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         depth, x, y, w, h;
        int         leftPad;
        unsigned int format;
        int         *pImage;

      void CopyArea (pSrcDrawable, pDstDrawable,
                   pGC, srcx, srcy, width, height, dstx, dsty)
        DrawablePtr pSrcDrawable, pDstDrawable;
        GCPtr       pGC;
        int         srcx, srcy;
        int         width, height;
        int         dstx, dsty;

      void CopyPlane (pSrcDrawable, pDstDrawable,
                    pGC, srcx, srcy, width, height, dstx, dsty, plane)
        DrawablePtr pSrcDrawable, pDstDrawable;

X11 Server Extension                                           Page 18
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


        GCPtr       pGC;
        int         srcx, srcy;
        int         width, height;
        int         dstx, dsty;
        unsigned int plane;

      void PolyPoint (pDraw, pGC, mode, npt, pptInit)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         mode;           /* Origin or Previous */
        int         npt;
        xPoint      *pptInit;

      void Polylines (pDraw, pGC, mode, npt, pptInit)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         mode;           /* Origin or Previous */
        int         npt;            /* number of points */
        xPoint      *pptInit;

      void PolySegment (pDraw, pGC, nseg, pSegs)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         nseg;
        xSegment    *pSegs;

      void PolyRectangle (pDraw, pGC, nrects, pRects)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         nrects;
        xRectangle  *pRects;

      void PolyArc (pDraw, pGC, narcs, parcs)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         narcs;
        xArc        *parcs;

      void FillPolygon (pDraw, pGC, shape, mode, count, pPts)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         shape, mode;
        int         count;
        xPoint      *pPts;

      void PolyFillRect (pDraw, pGC, nrectFill, prectInit)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         nrectFill;      /* number of rectangles to fill */
        xRectangle  *prectInit;     /* Pointer to first rectangle to fill */

      void PolyFillArc (pDraw, pGC, narcs, parcs)
        DrawablePtr pDraw;
        GCPtr       pGC;

X11 Server Extension                                           Page 19
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


        int         narcs;
        xArc        *parcs;

      int PolyText8 (pDraw, pGC, x, y, count, chars)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         x, y;
        int         count;
        char        *chars;

      int PolyText16 (pDraw, pGC, x, y, count, chars)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         x, y;
        int         count;
        unsigned short *chars;

      void ImageText8 (pDraw, pGC, x, y, count, chars)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         x, y;
        int         count;
        char        *chars;

      void ImageText16 (pDraw, pGC, x, y, count, chars)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         x, y;
        int         count;
        unsigned short *chars;

      void ImageGlyphBlt (pDraw, pGC, x, y, nglyph, ppci, pglyphBase)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         x, y;
        unsigned int nglyph;
        CharInfoPtr *ppci;          /* array of character info */
        unsigned char *pglyphBase;  /* start of array of glyphs */

      void PolyGlyphBlt (pDraw, pGC, x, y, nglyph, ppci, pglyphBase)
        DrawablePtr pDraw;
        GCPtr       pGC;
        int         x, y;
        unsigned int nglyph;
        CharInfoPtr *ppci;          /* array of character info */
        unsigned char *pglyphBase;  /* start of array of glyphs */

      void PushPixels (pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg)
        GCPtr       pGC;
        PixmapPtr   pBitMap;
        DrawablePtr pDraw;
        int         dx, dy, xOrg, yOrg;


X11 Server Extension                                           Page 20
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  4  INPUT


  This section discusses the  standard  extension  mechanisms  that  a
  server  provides  for input.  Some of these mechanisms may be useful
  for portable extensions.  However, we expect  that  the  many  input
  extensions   will  include  support  for  new  devices  and  require
  interaction  with  the  host  operating  system,  thus  making  them
  non-portable.




  4.1  Input Extension Sequence Of Events

  An input extension must make itself known to the server just as  any
  extension  does by calling AddExtension (see Section 10 on extension
  loading and initialization).   In  addition,  if  the  extension  is
  defining  a  new device (say a tablet or a button box), it makes the
  input device known to the server by the following call:

        AddInputDevice(deviceProc, autoStart)
                DeviceProc deviceProc;
                Bool autoStart

        typedef void (*DeviceProc)(/*DevicePtr, int */)

  where DeviceProc is a  procedure  which  the  server  will  call  to
  trigger device state changes, and DefaultOn is a boolean which tells
  whether the device is to be turned on by default .

  Later, when the server  is  ready  to  have  the  device  initialize
  itself, it will call DeviceProc as follows:

        DeviceProc(pDev,mode)
                DevicePtr pDev;
                int mode;

  with mode set to the value DEVICE_INIT <input.h>.   At  this  point,
  the extension must call one of the following routines:

  void InitPointerDeviceStruct(dev, map, mapLength, motionProc, controlProc)
      DevicePtr dev;
      BYTE *map;
      int mapLength;
      void (*controlProc)();
      int (*motionProc)();
   
  void InitKeyboardDeviceStruct(dev, map, mapLength, bellProc, controlProc)
      DevicePtr dev;
      BYTE *map;
      int mapLength;
      void (*bellProc)();
      void (*controlProc)();

X11 Server Extension                                           Page 21
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


   
  void InitOtherDeviceStruct(dev, map, mapLength)
      DevicePtr dev;
      BYTE *map;
      int mapLength;

  depending on what kind of input device the extension is  supporting.
  In  these  routines,  map  and mapLength specify byte arrays.  Input
  device mapping is defined in the X11 protocol.  The routine pointers
  (*bellProc, *controlProc, *motionProc) are defined as follows:

        void Bell(loud, pDevice)
            int loud;
            DevicePtr pDevice;

        void ChangeKeyboardControl(device, ctrl)
            DevicePtr device;
            KeybdCtrl *ctrl;

        void ChangePointerControl(device, ctrl)
            DevicePtr device;
            PtrCtrl *ctrl;
  Called to informs the extension of the new settings.

        int GetMotionEvents(pDevice, buff, start, stop)
            CARD32 start, stop;
            DevicePtr pDevice;
            xTimecoord *buff;

  Extension must fill in buff with all the  motion  events  that  have
  times  (32-bit  milliseconds,  not the 64-bit internal time) between
  start and stop.

  At this point, if  DefaultOn  was  true,  the  device  should  start
  processing input.

  DeviceProc may also be called with modes of  DEVICE_ON,  DEVICE_OFF,
  and  DEVICE_CLOSE.  In these cases, the device must start processing
  input, stop processing input, and close itself respectively.

  The input device extension must format input into a packet called an
  xEvent,  which  is  defined  in  section 12.  What it does with this
  packet and how  the  server  determines  that  there  is  now  input
  available  is  server-dependent.  For the MIT X11 Sample Server, the
  input device driver places an Xevent on a common  queue.   (See  the
  MIT  DDX  documentation  for  details.) The core server periodically
  checks this queue to determine whether there is new input available.

  When the server determines that there is new  input  available,  for
  each        event        it        calls        the        procedure
  DeviceRec->ProcessInputProc(xEvent) which points  to  a  routine  to
  process  the input.  Usually, this is a server routine which formats
  and routes the event to the proper client.  However an extension may
  intercept this call by placing a routine of its own in DeviceRec.

X11 Server Extension                                           Page 22
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  Possible core server routines which may be used for ProcessInputProc
  are:

   o  ProcessPointerEvent (for pointers)

      The event must be a keyButtonPointer event.

   o  ProcessKeyboardEvent (for keyboards)

      The event must be a keyButtonPointer event.

   o  ProcessOtherEvent (for other devices)

      No interpretation of the event is done.


  In addition, an input extension may do the  following  things  in  a
  portable way:



  4.2  Cause A Device To Be Grabbed Or UnGrabbed


  To cause a grab, an extension fills in a Grab  structure  and  calls
  the routine

        GrabPtr SetDeviceGrab(Dev,Grab)
                DevPtr Dev;
                GrabPtr Grab;


  This routine returns the previous grab structure.   For  ungrabbing,
  the extension passes NULL for the grab structure.



  4.3  Associate A Device With A Window


  This will cause events from the device to be directed to the  window
  if  the  device  is  not  grabbed.   To  associate the device with a
  window, an extension puts the address of the window  structure  (the
  value  which comes from a resource lookup on the window ID) into the
  Device->WindowPtr.



  4.4  Intercept Input From The System Devices Or Other Extensions


  To intercept input from another device, an extension must first find
  the  Device  structure  for the interceptee.  The following routines
  are available to find the addresses of Device  data  structures  for

X11 Server Extension                                           Page 23
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  the system pointer device and for the system keyboard device.

        LookupKeyboardDevice()
        LookupPointerDevice()

  Both return a pointer to the  device  structure  for  the  specified
  device.

  To intercept input  from  another  extension,  the  extensions  must
  cooperate  in  such a way that the interceptee gives the interceptor
  the address of its Device structure.

  Given the interceptee's device structure, an extension can intercept
  input  by  replacing Device->ProcessInput with a routine of its own.
  The extension can  the  modify  the  XEvent,  return  without  doing
  anything  with  it, pass the original or modified event to the input
  processing routine that was originally in  Device->ProcessInput,  or
  generate 1 or more completely new or different events.



  4.5  Getting An Event Mask

  If multiple clients need to select on an event, an event  mask  must
  be  assigned  to the event number.  Two routines are supplied by the
  server to facilitate getting and setting event masks.

        Mask GetNextEventMask()

        SetMaskForEvent(mask,event)
                Mask mask;
                int  event;

  GetNextEventMask returns the next available event mask, or  NULL  if
  there  are  none free.  (Event masks are scarce resources, so do not
  allocate  them   gratuitously.)   SetMaskForEvent   associates   the
  specified  mask  with the specified event number and makes the event
  filterable with that mask.

  If no mask is assigned to an event type, and the device causing  the
  event is not grabbed, that event will be sent only to the client who
  created the window associated with the event.



  4.6  Polling For Input

  Many server implementations must poll input extensions to  determine
  whether  there  is  input  ready.   Because  this  is a frequent and
  time-critical operation, the method by which and extension  receives
  poll  requests  has  been left server implementation dependent.  For
  example, in the MIT sample server, input device drivers place events
  on  a  common  queue, and the core server periodically checks to see
  whether the queue is empty.

X11 Server Extension                                           Page 24
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  5  EXTENSION REQUESTS

  As part of the initialization of an extension,  the  extension  must
  supply  a routine for the dispatcher to call when a request for that
  extension   is   received.    (See   section   10.1,   LOADING   AND
  INITIALIZATION; Making The Extension Known To The Server for details
  of how these are specified.)

  When  the  dispatcher  receives  a  client  request  containing  the
  extension's  major  opcode,  it calls the extension request routine,
  passing the client data structure.  All  further  interpretation  of
  the  request  is the responsibility of the extension, although there
  is a helpful macro supplied for C  language  bindings  (see  below).
  The  format  which  the  server  will  use for calling the extension
  request routine is:

                      int ExtensionRequest(Client)

  The extension must return SUCCESS <X.h>  if  the  request  completed
  successfully.  Otherwise, it must return an error code (see the next
  section for a discussion of errors).

  For drawing  operations,  the  extension  must  call  the  following
  routine:

  int GetGCAndDrawableAndValidate(gcID, pGC, drawableID, pDraw, client)
      int gcID;
      GC *pGC;
      int drawableID;
      DrawablePtr pDraw;
      ClientPtr client;

  This routine accepts gcID,drawableID, and client.  It looks  up  the
  gcID  and drawableID in the resource manager and returns BadDrawable
  or BadGC if there is a problem.  If the lookups are  successful,  it
  check  to  see  whether a GC validate is required; if so it performs
  the validation.  It then returns pGC, and  pDraw  and  a  status  of
  SUCCESS<X.h>.



  5.1  Additional Utility Functions Available


  The following are macros defined for use by extension-writers  using
  the C language.  Writers in other languages will have to invent ways
  of doing similar things (or perhaps some  server  implementors  will
  provide   bindings   for   other   languages).    They  assume  that
  RequestStructure is a structure defining what an incoming buffer for
  a particular request type looks like.

X11 Server Extension                                           Page 25
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  5.1.1  REQUEST(RequestStructure) -

  Its purpose is to define a record called  stuff  which  is  of  type
  RequestStructure,  and  which is bound to the request buffer.  After
  an invocation of REQUEST, you can refer to  fields  in  the  request
  buffer using

       stuff->requestField



  5.1.2  REQUEST_SIZE_MATCH(RequestStructure) -

  REQUEST_SIZE_MATCH checks to make sure the the request in "stuff" is
  the  right size for the particular request.  It assumes that REQUEST
  has already been invoked.  It  returns  BadLength  if  the  size  is
  incorrect.



  5.1.3  REQUEST_AT_LEAST_SIZE(RequestStructure) -

  Same  as  REQUEST_SIZE_MATCH,   except   that   it   is   used   for
  variable-length  requests.   It checks to make sure that the request
  is no shorter than the minimum size.  It returns  BadLength  if  the
  size is invalid.



  6  EXTENSION-GENERATED REPLIES

  A portable extension may define requests that  generate  replies  as
  part  of its protocol.  It may then generate these replies using the
  routine

        WriteReplyToClient(client,length,buf)
                ClientPtr cleint;
                int length;
                unsigned char *buf;

  where  buf  contains  the  reply.   The  extension   is   completely
  responsible  for  formatting the reply to match what is specified in
  the extension's protocol.  (Of course, the extension  protocol  must
  define the extension reply to look like a reply, as defined in the X
  core protocol.)



  7  EXTENSION-GENERATED ERRORS

  A portable extension may generate core errors  or  extension-private
  errors to send to a client.  In order to send an error, an extension
  must have allocated its private errors using the  AddExtension  call
  (see the section on loading).  It receives back the first error code

X11 Server Extension                                           Page 26
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  that it is allowed to use.  If it has asked for more than one  code,
  the others follow in sequence.

  An extension calls the following routine to generate an error:

  SendErrorToClient(client,reqCode,minorCode,status,resourceID)
                  ClientPtr client;
                  char reqCode,minorCode,status;
                  XID resourceID;

  Client is the client structure passed  to  the  extension  with  any
  request.   reqCode  and minorCode are the extension major opcode and
  minor opcode respectively, status is one of the error codes assigned
  to  the  calling  extension  or  a  core  error, and resourceID is a
  parameter that the extension may use to return a resourceID that  is
  involved  in the error.  If a resourceID is not defined in the error
  that the extension is sending, the extension should pass None  <X.h>
  here.

  This sort of error should only be sent for errors which  the  client
  has made which are defined by the extension .  It should not be used
  for internal consistency checks, hardware errors, etc.

  If an extension sends an error, it is expected to  return  an  error
  code  from  MainFunc  or  SwappedMainFunc.   If  it does not send an
  error, it must return SUCCESS<X.h>.



  8  RESOURCES

  There is a resource manager in servers which  a  standard  extension
  may  use  to  convert  resource ids specified by the client into the
  address of a data structure in the server.

  Resources are identified by a resource ID.

  A resource contains a  set  of  class-value  pairs.   Class  RC_CORE
  <Xproto.h>  is  used  by the core server.  The value associated with
  class RC_CORE for a resource is generally  the  address  of  a  data
  structure  in the server which represents that resource.  Additional
  classes may be allocated  by  an  extension.   The  class  mechanism
  allows  an extension to associate additional, extension-private data
  with a resource.  Typically, an extension would allocate a class  to
  associate its own value with a resource.  For example, it could then
  put the address of a GCInterest structure in this class of  each  GC
  that it is interested in.

  A resource has a type.  Examples of resource types are  window,  GC,
  font,  etc.   Given  a  resource ID, a class, and a mask of expected
  types, the resource  manager  can  determine  whether  the  resource
  really  is  of  one  of  those  types.   Notice that type values are
  bitmasks so that it is meaningful to  OR  two  or  more  type  codes
  together.  There is also a special value RT_ALLTYPES which is a type

X11 Server Extension                                           Page 27
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  mask of all ones.

  A standard extension may do the following things with resources:

   o  Create a new resource class

                        int CreateNewResourceClass()

      This routine returns a new class.  Classes  are  useful  because
      they allow an extension to create a new resource (for example an
      extension-private GC) which has the same ID as a core resource.

   o  Create a new resource type

      New resource types  may  be  created  by  extensions  using  the
      routine

                        int CreateNewResourceType()

      This routine returns a new resource type code which can then  be
      used  with  the  other  resource  routines.  It returns -1 if it
      fails.

      Note that types are scarce in a server, so do  not  create  them
      gratuitously.

   o  Create a resource ID

                 int FakeClientId(client)

                     ClientPtr client

      This routine creates a resource ID for the specified client.  It
      is  useful  if  an  extension wishes to create a resource (say a
      pixmap).   Because  the  client  is  responsible  for   creating
      resource  IDs,  the  extension  must  use  this  routine,  which
      generates IDs in a different name  space,  to  ensure  that  the
      resource ID will be unique.

      This resource will be deleted automatically when the  client  is
      disconnected  from  the  server.  To create a resource that does
      not get automatically deleted, use FakeClientID with a client of
      serverClient <global>.

   o  Associate a resource value and type with a resource ID and class

        AddResource(ID,type,value,func,class)
                XID ID
                short type
                int   value
                void (*func)()
                short class

      This routine adds a  new  resource  class-value  pair  into  the

X11 Server Extension                                           Page 28
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


      resource  manager,  given  a resource ID, class type, and value.
      If the resource does not already exist, it is created.  Func  is
      a function which is called when the resource is freed.

      When you use AddResource, the resource ID must come either  come
      from  the  client  itself  or  from FakeClientId to avoid naming
      conflicts.  Notice that a valid resource ID implicitly  contains
      the  identity of the client.  The resource will be automatically
      freed when the client shuts down.

   o  Free a resource

                    FreeResource(ID,SkipDeleteCallClass)

      This routine frees (all classes of) the  resource  specified  by
      ID, and calls the delete function for each class associated with
      that   resource   except   the    function    associated    with
      SkipDeleteCallClass.   SkipDeleteCallClass  may have the special
      value RC_NONE, in which case the delete function will be  called
      for all classes.

   o  Find the value of a resource and check for correct type

                          LookupID(ID,rType,class)

      Returns the value associated with the specified ID and class  if
      the type associated with that resource is one of those specified
      by rType.  Otherwise, it returns null.  A valid value for  rType
      is  RT_ANY  <Xproto.h>,  which will cause LookupID to return the
      value of the ID-class pair regardless of its type.


  Note  that  resources   may   be   freed   implicitly   under   some
  circumstances.   For  example, when the server resets, all resources
  will be freed.  If a client disconnects, resources that  it  created
  and   resources  created  on  its  behalf  using  ids  generated  by
  FakeClientID will be deleted.



  9  ATOMS

  A standard extension may use the following routines  to  create  and
  look up atoms:

   o  MakeAtom(string,len,makeit)
      char *string;
      int len;
      bool makeit;

      This function returns the ATOM made of the specified string.  If
      makeit is false, None<X.h> is returned if there is no such atom.
      Otherwise, the atom is created and returned.

X11 Server Extension                                           Page 29
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


   o  bool ValidAtom(atom)

      Returns TRUE if the atom is non-null (i.e.  it is not None)  and
      valid.

   o  char *NameForAtom(atom)

      Returns a pointer  to  the  0-terminated  string  value  of  the
      specified   atom   if  it  exists.   This  string  must  not  be
      deallocated or written into.  If the string value for  the  atom
      does not exist, NameForAtom returns NONE <X.h>.

  Notice that once an atom is created, you cannot free  it.   It  will
  only be freed when the server resets.



  10  LOADING AND INITIALIZATION

  There are two methods of loading an extension:  Linking it  in  with
  the   server,   and   loading   it  dynamically.   Different  server
  implementations can differ in the  methods  supported  or  required.
  This  section  specifies a mechanism which, if adhered to, will make
  the porting process simpler.



  10.1  Making The Extension Known To The Server

  This function is independent of how the extension is linked into the
  server.

  The extension's init routine must call the following routine:

  ExtensionEntry *AddExtension(name, NumEvents,NumErrors,MainProc,
       SwappedMainProc,SwapReplyProc,ResetProc)

        char *name;  /*Null terminate string; case matters*/
        int NumEvents;                
        int NumErrors;                
        int (* MainProc)();/*Called if client matches server order*/
        int (* SwappedMainProc)();/*Called if client differs from server*/
        void (* SwapReplyProc) ();/*Called to swap extension replies*/
        void (* ResetProc)();  

  The ExtensionEntry * value returned is  a  pointer  to  a  structure
  which defines the extension, including its opcodes, error codes, and
  event  codes.   The  structure  also  contains  an  extensionPrivate
  pointer  which the extension can use for any purpose.  Typically, it
  would be used as a pointer to resources which were allocated by  the
  extension  at  initialization  time,  and  which  must be freed when
  ResetProc is called.

  MainProc specifies where the  dispatcher  will  call  for  extension

X11 Server Extension                                           Page 30
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  requests  if  the  client  data  type is the same as the server.  It
  returns Success <X.h> or an error number.  If there is an error,  it
  will  not  be  sent to the client.  The extension is expected to use
  SendErrorToClient to do that.  The only parameter to MainFunc is the
  client object for the current client.

       (For details on the operation of MainProc, see section 5,

       EXTENSION REQUESTS.)


  SwappedMainProc(Client) is  called  in  place  of  MainProc  if  the
  client's  byte  ordering is different from the server.  This routine
  must  rearange  the  bytes  and  then  act  like  MainProc.   It  is
  acceptable  for SwappedMainProc to do the swapping in place and pass
  the same client object to MainProc.

  ResetProc(pExtension) is called when the server closes down (has  no
  more  clients).  The purpose of reset is to return the server to the
  state it was in when it started up.  After reset, the  extension  is
  no  longer  defined.   This routine must release all resources which
  the extension is holding and make arrangements with the OS dependent
  load  routine  to have its init routine called again before the next
  time it is used.  This procedure is called when  the  server  closes
  down before any other server resources are freed.  Its argument is:

  ExtensionEntry pExtension;

  SwapReplyProc(pClient,size,pbuf) is called by  SendToClient  if  the
  client  has  a  different  byte  orientation  from the server.  This
  routine is responsible for determining what type of extension  reply
  is  being  returned  and for rearranging the appropriate bytes.  Its
  arguments are:

        ClientPtr       pClient;
        int             size;           /* in bytes */
        unsigned char   *pbuf;

  where pClient is a pointer to the client structure, size is the size
  of  the  reply  to  be  swapped,  and  pbuf is a pointer to a buffer
  containing the reply to be swapped.  The  extension  must  determine
  the type or reply (based on the original request which is pointed at
  from the client structure) and swap the reply appropriately.  If the
  extension  implements more than one request (using a subopcode), the
  extension is responsible for looking at the subopcode  to  determine
  how to swap the reply.

  Note that even if the extension does not send any replies  something
  must  be  supplied  for  SwapReplyProc,  although  it  may be a null
  routine.  Otherwise, the call to AddExtension will fail.

X11 Server Extension                                           Page 31
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  10.2  Making Event Swappers Known To The Server

  For each event that the extension supports, it must tell the  server
  about  a  routine  to do byteswapping for that event.  The extension
  does this by calling the following routine once for each event:

      AddEventSwapper(event, SwapEventProc)
        int     event;
        void    (* SwapEventProc)();

  where event is the number of an extension event.  SwappedEventProc a
  pointer  to  a  procedure  for swapping the event.  SwapEventProc is
  called with the following three arguments:

        ClientPtr       pClient;
        int             numEvents;
        unsigned char   *pbuf;

  Note that we pass a number of events rather than  the  size  of  the
  buffer.   Events are always 32 bytes long.  The event swapper may be
  called with a buffer containing multiple events.

  It is the SwapEventProc's responsibility to determine what  kind  of
  event is being sent so that it can tell which data types are located
  where.  The extension needs this information because different  data
  types must be rearranged differently (a char is not changed, a short
  has its bytes swapped, an int has its bytes reordered).



  10.3  Linked In Extensions

  If an extension is linked in with the server, the server must supply
  the sources to a routine called InitExtensions(), a routine which is
  called when the server starts up.  When a new  extension  is  added,
  this  routine  must  be  modified  to call the server initialization
  routine.  The extension and the modified InitExtensions() must  then
  be linked with the server in a server and OS dependent manner.



  10.4  Dynamically Loaded Extensions

  This  is  even  more  operating  system  dependent  than  linked  in
  extensions.   In  this  case,  the  extension  must  be set up to be
  loadable  according  to  the  requirements  of  the  OS  and  server
  implementation.   One general requirement is that the server must be
  able to calculate the name of the init routine given  the  extension
  name.   Thus  the following rule:  The name of the init routine must
  be the name of the extension with "Init" added on the end.  If  this
  name  is  longer  than  the  operating  system  allows, it should be
  truncated on the right.

  Example:  You have an extension named Magic.  Its init routine  must

X11 Server Extension                                           Page 32
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  be  named  MagicInit.   If  the operating system only allows globals
  with up to 8 characters, then the name must be MagicIni.   Case  may
  or  may not count depending on the operating system.  Best to assume
  it does.



  11  EXTENDED FUNCTIONS

  Server and device  support  implementors  will  want  to  expose  to
  extension  writers  certain  procedures  that are not defined in the
  core protocol and the sample  server.   One  might  think  of  these
  procedures  as  additional  interfaces  to  the device drivers.  For
  instance, they might want to define a procedure  that  does  rotated
  text.

  The following routine is used to look up these procedures, based  on
  a  character  string  name.   The standard naming of the procedures,
  their actual semantics and parameters are not addressed  here,  only
  the mechanism.

  As an example of the use of these procedures, consider rotated text.
  First  we  assume  that  the string "RotatedText" is known (via some
  standards process  which  is  not  defined  here)  to  be  the  name
  associated  with  a text rotation function.  Further, we assume that
  the arguments to this routine  are  known  via  the  same  standards
  process.   To make this capability available to extension writers, a
  server implementor would register the name  RotatedText  along  with
  the address of a routine which does it.

  Now an extension  which  implements  a  rotated  text  protocol  can
  determine  whether  there  is  a routine to draw the rotated text by
  looking up "RotatedText".  If it is there,  the  extension  can  use
  that  routine  rather  than  providing  software  simulation  of the
  function  by  calling  through  the  GC  to  the  standard   drawing
  functions.   If  the  RotatedText  routine  is defined properly, the
  extension could place it directly in the GC procedure vector  during
  validation to replace standard text routines.

  The following procedure may be  used  to  lookup  extended  function
  names:
   
  void (* LookupProc(name,pGC))()
        char *name;
        GC *pGC

  Looks up the procedure associated with name for the screen which  is
  associated  with  the  specified  GC.   Matching  on  name  is  case
  sensitive.  "name" is a null terminated string.  Note that  void  is
  the  type of the returned procedure, not the type of LookupProc.  If
  no procedure with the specified name has  been  registered  for  the
  specified  GC, LookupProc returns null.  In this case, the extension
  should  simulate  the  behavior  of  the  desired  procedure,  using
  standard interfaces defined in this document.

X11 Server Extension                                           Page 33
Copyright (c) Digital Equipment Corporation, 1987       31 August 1987


  The following procedure may be used to register an extended function
  name that may later be looked up with LookupProc:

    void RegisterProc(name, pGC, proc)
      char *name;
      GC *pGC;
      ExtensionLookupProc proc;

  Registers the procedure proc to be  associated  with  name  for  the
  screen  which is associated with the specified GC.  Matching on name
  is case sensitive.  "name" is a null terminated string.   There  may
  be  a  need  to register a procedure before any GC has been created.
  If this is the case,  a  scratch  GC  must  be  created,  using  the
  following procedure:

    GC *CreateScratchGC(pScreen, depth)
      ScreenPtr pScreen;
      int depth;

  where depth is the depth of pScreen, and then freed using:

    void FreeGC(pGC, gid)
      GC *pGC;
      int gid;













                              APPENDIX A

                          EXPOSED STRUCTURES



This section documents the structures which we are explicitly exposing
to  portable  extensions.   If  a structure appears in this list, that
implies that all servers which support this extension  interface  must
also  provide  these structures with at least the fields defined here.
Conversely, if extensions  use  structures  or  fields  that  are  not
defined  here,  they will not be portable.  Note that this section may
only  a  subset  of  the   fields   in   these   structures.    Server
implementations   may   define  additional  fields  which  a  portable
extension may not use.

Each section indicates which .h file the structure is defined in,  the
definition of the parts of the structure which are exposed to portable
extensions, and any additional typedefs that are assumed or required.



A.1  GC (GRAPHIC CONTEXT)


GC structures directly correspond to GCs used by the client.

#include "gc.h"

This structure should never be dereferenced, but may be accessed using
the routines specified in sections 2 and 3.

typedef pointer GCPtr;



A.2  GCINTEREST


These structures are used by an extension to request notification when
changes happen to a GC.  Extensions create a GCInterest data structure
for each GC that they wish to express interst in.  See section 2.

GCInterest structures are defined using the statement

#include "gcstruct.h"

EXPOSED STRUCTURES                                            Page A-2
                                                        31 August 1987



typedef struct _GCInterest{

    GCInterest  *pNextGCInterest
    GCInterest  *pLastGCInterest
    int         length
    ATOM        owner           /*Extension ID atom of owning extension*/
    unsigned long       ValInterestMask  /*Match stateChanges in GC*/
    Bool (* ValidateGC)(); /*Called if any bit in interestMask matches a GC*/
                           /*  stateChanges bit*/
    unsigned long       ChangeInterestMask  /*Match stateChanges in GC*/
    int  (* ChangeGC)();   /*Called when this GC is the object of a ChangeGC request*/
    void (* CopyGCSource) ();
                            /*Called when this GC is the source of a CopyGC*/
    void (* CopyGCDest) ();
                            /*Called when this GC is the destination of a CopyGC*/
    void (* DestroyGC) ();  /*Called when this GC is about to be deleted*/

    pointer     extPriv;    /* Pointer to anything.  Private to the
                                extension owning this GCInterest*/

} GCInterestRec;

#include "gc.h"

typedef struct _GCInterest *GCInterestPtr




A.3  CLIENT

This  structure  defines  the  current  state  of  the  client.   This
structure is required by several routines including the error routine.
It is passed to the extension's MainProc or  SwappedMainFunc  when  an
extension protocol request is made.

Extension must not write into the client structure.
#include "dixstruct.h"

typedef struct _Client {              
    int client;                       
    Mask clientAsMask;                
    pointer requestBuffer;            
    int sequence;                     
} ClientRec, *ClientPtr;



A.4  DRAWABLE

This structure should never be dereferenced, but is passed  into  many
drawing operations.

EXPOSED STRUCTURES                                            Page A-3
                                                        31 August 1987


typedef pointer DrawablePtr;



A.5  PIXMAP

This structure should never be dereferenced, but is passed  into  many
drawing operations.

typedef pointer PixmapPtr;



A.6  DEVICE

This structure should never be dereferenced, but is passed  into  many
input operations.

#include "input.h"

typedef pointer DevicePtr;



A.7  XEVENTS

#include <Xproto.h>

typedef struct _xEvent {
    BYTE type; /*Standard types in X.h.  Extension defines additional types*/
    BYTE detail; /*Key or button number*/
    union {
        struct {
            INT16 rootX, rootY; /*Event X and Y relative to the screen 
                                Upper left of cursor */
            Timestamp time; /*Server time in milliseconds when event happened*/
         } keyButtonPointer;
     }u;    
} xEvent;




A.8  GRAB

The grab structure describes the situation when  an  input  device  is
grabbed.   When  a device is grabbed, a pointer to a grab structure is
placed in Device->GrabPtr.  The definition of the grab structure is as
follows:

#include "input.h"

  typedef struct _Grab {                                                       
    WindowPtr           window;                                                

EXPOSED STRUCTURES                                            Page A-4
                                                        31 August 1987


} GrabRec, *GrabPtr;



A.9  EXTENSIONENTRY


A pointer to this structure is returned by AddExtension.   It  defines
the  extension opcode and the event and error ranges for the extension
which was just defined.
include "extnsionst.h"

typedef struct _ExtensionEntry {
    int index;
    char *name;               /* extension name */
    int base;                 /* base request number */
    int eventBase;            
    int eventLast;
    int errorBase;
    int errorLast;
    pointer extPrivate;       /*Hook for the extension to use*/
} ExtensionEntry;




A.10  XSEGMENT

#include <Xprotostr.h>

typedef struct _xSegment {
    INT16 x1, y1, x2, y2;
} xSegment;



A.11  XPOINT

#include <Xprotostr.h>

typedef struct _xPoint {
        INT16           x,y;
} xPoint;



A.12  DDXPOINT


#include <miscstruct.h>
typedef struct _DDXPointRec {
    short int x;
    short int y;
    } DDXPointRec;

EXPOSED STRUCTURES                                            Page A-5
                                                        31 August 1987



#include <misc.h>
typedef struct _DDXPointRec *DDXPointPtr;



A.13  XRECTANGLE


#include <Xprotostr.h>

typedef struct _xRectangle {
    INT16 x, y;
    CARD16  width, height;
} xRectangle;




A.14  XARC


#include <Xprotostr.h>

typedef struct _xArc {
    INT16 x, y;
    CARD16   width, height;
    INT16   angle1, angle2;
} xArc;




A.15  CHARINFOPTR


#include "font.h"

typedef pointer CharInfoPtr;



A.16  POINTER


#include "misc.h"

typedef unsigned char *pointer;














                              APPENDIX B

              ROUTINES AVAILABLE TO PORTABLE EXTENSIONS



###TBS###













                              APPENDIX C

              CONSTANTS AVAILABLE TO PORTABLE EXTENSIONS



###TBS###













                              APPENDIX D

            INCLUDE FILES AVAILABLE TO PORTABLE EXTENSIONS




In X11/include:
    X.h
    Xproto.h
    Xprotostr.h

In X11/server/include
    misc.h
    extnsionst.h
    dixstruct.h
    gc.h
    gcstruct.h
    input.h
    font.h
    resource.h
    opaque.h














                              APPENDIX E

               ZOID--A SAMPLE EXTENSION IMPLEMENTATION



     E.1  INTRODUCTION

 
     This example is slightly contrived, so that some of the
alternatives in implementing an extension can be exposed.
 
     The 2  protocol  requests  for  the  example  extension
(called ZOID from here on) are:
 
PolyFillTrapezoid
 
     drawable: DRAWABLE
     gc: GCONTEXT
     trapezoids: LISTofX-TRAPEZOID or LISTofY-TRAPEZOID
 
     Errors: Drawable, GContext, Match
 
     Fills the specified trapezoids, using the alignment set
     by SetTrapezoidAlignment.  The coordinates of each tra-
     pezoid are relative  to  the  drawable's  origin.   The
     alignment  determines the aligned axis of the trapezoid
     and how to determine the points  that  follow.   If  y-
     aligned,  then  use Y_TRAPEZOID.  The default alignment
     is y-aligned.
 
     The rectangles are drawn in the order listed.  For  any
     given  trapezoid, no pixel is drawn more than once.  If
     trapezoids intersect, the intersecting pixels are drawn
     multiple times.

     Going clockwise around an X aligned trapezoid, the corners are
     determined by
     [x1, y1], [x2, y3], [x2, y4], [x1, y2].
     Going clockwise around an Y aligned trapezoid, the corners are
     determined by
     [x1, y1], [x2, y1], [x4, y2], [x3, y2].
 
     GC components:  alu-function,  plane-mask,  fill-style,
     fill-rule,   subwindow-mode,   clip-x-origin,   clip-y-
     origin, clip-mask

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                       Page E-2
                                                        31 August 1987


 
     GC mode-dependent components: foreground,  tile,  stip-
     ple, tile-stipple-x-origin, tile-stipple-y-origin
 
     X-TRAPEZOID: [ y1, y2, y3, y4: INT16,         
        x1,  x2:     INT16 ]
 
     Y-TRAPEZOID: [ x1, x2, x3, x4: INT16,          
        y1,  y2:     INT16 ]
 
SetTrapezoidAlignment
 
     gc: GCONTEXT
     mode: {y-aligned, x-aligned}
 
     Errors: GContext, Value
 
     Sets the trapezoid alignment for  gc  for  PolyFillTra-
     pezoid.   This  mode  determines  how  the  points  are
     presented (either X-TRAPEZOID or Y-TRAPEZOID).
 



E.2  THEORY OF OPERATION

 
     To the client, a trapezoid is used like any other  core
output request.  Internally, ZOID follows the same scheme as
the core gc with procedure  pointers  and  lazy  evaluation.
However,  since trapezoid is a new primitive, ZOID must keep
its own state attached to the gc in  the  GCInterest  queue.
This  state  consists of [alignment: int, PolyFillTrap: pro-
cedure].
 
     In order to take  advantage  of  any  special  hardware
features,  ZOID first queries the core server for any avail-
able trapezoid  routines  (using  LookupProcedure),  and  if
there  isn't  one,  converts the points into a form suitable
for FillPoly.  At ValidateGC time,  if  ZOID  has  expressed
interest  in the gc being validated (added a GCInterest ele-
ment to the gc's queue), ZOID looks  at  the  current  fill-
style  and  alignment  to  determine  the procedure to call.
ZOID queries the core server for  the  following  procedures
(this  assumes  some  standard naming and documentation that
has been done magically):
 
     PolySolidYAlignedTrap(pDrawable, pGC, numTraps, points)
 
     PolyStippledYAlignedTrap(pDrawable,   pGC,    numTraps,
     points)
 
     PolyTiledYAlignedTrap(pDrawable, pGC, numTraps, points)
 

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                       Page E-3
                                                        31 August 1987


     PolySolidXAlignedTrap(pDrawable, pGC, numTraps, points)
 
     PolyStippledXAlignedTrap(pDrawable,   pGC,    numTraps,
     points)
 
     PolyTiledXAlignedTrap(pDrawable, pGC, numTraps, points)
 
     ZOID caches  its  own  GCInterest  structure  with  the
resource  manager  using the new class RC_ZOID and core type
RT_GC.  This will allow quick lookup of the ZOID state.
 
     ZOID does not keep an explicit list of gcs that it  has
expressed interest in.  Instead, it relies on looking up the
gc in the resource manager.  If its GCInterest element isn't
attached to the gc, ZOID puts its element on at lookup time.
The GCInterest element is always inserted at the end,  after
the  core  device,  since  ZOID depends on the core FillPoly
procedure being set correctly.
 
     The only function in the GCInterest structure that ZOID
is  interested in is ValidateGC.  The ValInterestMask is the
OR   of   GCFillStyle,   GCFillRule,   GCTile,    GCStipple,
GCTileStipXOrigin, GCTileStipYOrigin.  When the alignment is
set in SetTrapezoidAlignment,  the  GCExtensionInterest  bit
will  also  be set, so ValidateGC will call ZOID.  The GCEx-
tensionInterest bit will be cleared after ValidateGC is com-
pleted.
 



E.3  CODE (ZOID.C)

 
#include <stdio.h>
#include "X.h"
#include "Xproto.h"
#include "misc.h"
#include "os.h"
#include "pixmapstr.h"
#include "gcstruct.h"   /* should be able to get GCInterestRec without GC */
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include "zoid.h"

typedef struct _ZoidState {
    char alignment;
    void (*PolyFillZoid)();
} ZoidStateRec, *ZoidStatePtr;

static Atom zoidAtom;
static int ZoidReqCode = 0;

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                       Page E-4
                                                        31 August 1987


static short ZoidClass = 0;

/* ZoidProcVector is used in the ZOID validate routine */

void (* ZoidProcVector[6]) ();
extern void ValidateGC();

/****************
 * ZoidExtensionInit
 *
 * Called from InitExtensions in main() or from QueryExtension() if the
 * extension is dynamically loaded.
 *
 * ZOID has no events or errors (other than the core errors)
 ****************/

void
ZoidExtensionInit()
{
    ExtensionEntry *extEntry, *AddExtension();
    int ProcZoidDispatch(), SProcZoidDispatch();
    void ZoidSwapReplyProc(), ZoidResetProc();

    extEntry = AddExtension(ZOIDNAME, 0, 0, ProcZoidDispatch,
                   SProcZoidDispatch, ZoidSwapReplyProc, ZoidResetProc);
    if (extEntry)
    {
        ZoidReqCode = extEntry->base;
        zoidAtom = MakeAtom(ZOIDNAME, 13, TRUE);
        ZoidClass = CreateNewResourceClass();

        /*
         * at PolyFillTrapezoid time, if the procedure is NULL, then
         * points are converted to a polygon and the gc's fill polygon call
         * is used
         */
        bzero(ZoidProcVector, sizeof(ZoidProcVector));
    } else {
        FatalError("ZoidExtensionInit: AddExtensions failed\n");
    }
}

/****************
 * ZoidValidateState
 *
 * Called from ValidateGC.
 *
 ****************/

void
ZoidValidateState(pGC, pGCI, mask, pDrawable)
    GCPtr pGC;
    GCInterestPtr pGCI;
    int mask;

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                       Page E-5
                                                        31 August 1987


    Drawable pDrawable;
{
    ZoidStatePtr pZoidState = (ZoidStatePtr)pGCI->extPriv;

    switch (GetGCValue(pGC,fillStyle))
    {
        case FillSolid:
            if (pZoidState->alignment == XZoid_YAligned)
                pZoidState->PolyFillZoid = ZoidProcVector[SOLID_Y];
            else
                pZoidState->PolyFillZoid = ZoidProcVector[SOLID_X];
            break;
        case FillTiled:
            if (pZoidState->alignment == XZoid_YAligned)
                pZoidState->PolyFillZoid = ZoidProcVector[TILE_Y];
            else
                pZoidState->PolyFillZoid = ZoidProcVector[TILE_X];
            break;
        case FillStippled:
        case FillOpaqueStippled:
            if (pZoidState->alignment == XZoid_YAligned)
                pZoidState->PolyFillZoid = ZoidProcVector[STIP_Y];
            else
                pZoidState->PolyFillZoid = ZoidProcVector[STIP_X];
            break;
     }
#ifdef GCExtensionInterest
     pGCI->ValInterestMask &= ~GCExtensionInterest;
#endif GCExtensionInterest
}

/****************
 * AddAndInitZoidInterest
 *
 * Sets up at GCInterest ptr and places it on the GC's queue.
 *
 ****************/

static GCInterestPtr
AddAndInitZoidInterest(pGC)
    GCPtr pGC;
{
#define ZOID_INTEREST (GCFillStyle | GCFillRule | GCTile | GCStipple \
        | GCTileStipXOrigin | GCTileStipYOrigin)

    GCInterestPtr pGCI;
    ZoidStatePtr pZoidState;
    void ZoidFreeState();

    pGCI = (GCInterestPtr)Xalloc(sizeof(GCInterestRec));
    InsertGCI(pGC,pGCI,GCI_LAST,0)

    pGCI->ValInterestMask = ZOID_INTEREST;
    pGCI->ValidateGC = ZoidValidateState;

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                       Page E-6
                                                        31 August 1987


    pGCI->ChangeInterestMask = 0x0;
    pGCI->ChangeGC = NULL;
    pGCI->CopyGCSource = NULL;
    pGCI->CopyGCDest = NULL;
    pGCI->DestroyGC = ZoidFreeState;

    pZoidState = (ZoidStatePtr)Xalloc(sizeof(ZoidStateRec));
    pZoidState->alignment = XZoid_YAligned;
    pGCI->extPriv = (pointer)pZoidState;

    ZoidProcVector[SOLID_Y] = LookupProc("PolySolidYAlignedTrapezoid", pGC);
    ZoidProcVector[STIP_Y]  = LookupProc("PolyStipYAlignedTrapezoid", pGC);
    ZoidProcVector[TILE_Y] = LookupProc("PolyTiledYAlignedTrapezoid", pGC);
    ZoidProcVector[SOLID_X] = LookupProc("PolySolidXAlignedTrapezoid", pGC);
    ZoidProcVector[STIP_X]  = LookupProc("PolyStipXAlignedTrapezoid", pGC);
    ZoidProcVector[TILE_X] = LookupProc("PolyTiledXAlignedTrapezoid", pGC);

#ifdef GCExtensionInterest
    (* pGCI->ValidateGC) (pGC, pGCI, ZOID_INTEREST | GCExtensionInterest,
    NULL);
#else GCExtensionInterest
    (* pGCI->ValidateGC) (pGC, pGCI, ZOID_INTEREST, NULL);
#endif GCExtensionInterest
    return (pGCI);
}


/*****************
 * ProcPolyFillZoid
 *
 *****************/

static int
ProcPolyFillZoid(client)
    register ClientPtr client;
{
    int ntraps;
    register GCPtr pGC;
    register DrawablePtr pDraw;
    GCInterestPtr pGCI, prevGCI;
    REQUEST(xPolyFillZoidReq);          /* xPolyFillZoidReq *stuff; */
    ZoidStatePtr pZoidState;
    void ZoidDeleteState(), UseGCFillPoly();

    REQUEST_AT_LEAST_SIZE(xPolyFillZoidReq);
    GetGCAndDrawableAndValidate(stuff->gc, pGC, stuff->drawable,
        pDraw, client);

    pGCI = (GCInterestPtr) LookupID(stuff->gc, RT_GC, ZoidClass);
    if (!pGCI)
    {
        pGCI = AddAndInitZoidInterest(pGC);
        AddResource(stuff->gc, RT_GC, pGCI, ZoidDeleteState, ZoidClass);
    }

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                       Page E-7
                                                        31 August 1987


    ntraps = ((stuff->length << 2) - sizeof(xPolyFillZoidReq)) /
             sizeof(xXYTraps);
    pZoidState = (ZoidStatePtr)pGCI->extPriv;
    if (pZoidState->PolyFillZoid)
        (* pZoidState->PolyFillZoid)(pDraw, pGC, ntraps, &stuff[1]);
    else
        UseGCFillPoly(pDraw, pGC, pZoidState, ntraps, &stuff[1]);
    return (Success);
}


/*****************
 * ProcSetTrapazoidAlignment
 *
 *****************/

static int
ProcSetZoidAlignment(client)
    register ClientPtr client;
{
    register GCPtr pGC;
    GCInterestPtr pGCI;
    REQUEST(xSetZoidAlignmentReq);
    ZoidStatePtr pZoidState;
    void ZoidDeleteState();

    REQUEST_AT_LEAST_SIZE(xSetZoidAlignmentReq);
    if ((stuff->alignment != XZoid_YAligned)
    &&  (stuff->alignment != XZoid_XAligned))
    {
        SendErrorToClient(client, ZoidReqCode, X_SetZoidAlignment,
                          stuff->gc, BadMatch);
        return(BadMatch);
    }
    pGCI = (GCInterestPtr)LookupID(stuff->gc, RT_GC, ZoidClass);

    pGC = (GC *)LookupID(stuff->gc, RT_GC, RC_CORE);
    if (!pGC)
    {
        SendErrorToClient(client, ZoidReqCode, X_SetZoidAlignment,
                          stuff->gc, BadGC);
        return(BadGC);
    }

    if (!pGCI)
    {
        pGCI = AddAndInitZoidInterest(pGC);
        AddResource(stuff->gc, RT_GC, pGCI, ZoidDeleteState, ZoidClass);
    }
    pZoidState = (ZoidStatePtr)pGCI->extPriv;
    pZoidState->alignment = stuff->alignment;

        /* tell gc that an extension must be called at next Validate */
    SetGCMask(pGC, GCExtensionInterest, GCExtensionInterest);

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                       Page E-8
                                                        31 August 1987



        /* say that ZOID is the extension that is interested */
    pGCI->ValInterestMask |= GCExtensionInterest;
    return (Success);
}

/*****************
 * ProcZoidDispatch
 *****************/

int
ProcZoidDispatch(client)
    register ClientPtr client;
{
    REQUEST(xReq);
    if (stuff->data == X_PolyFillZoid)
        return(ProcPolyFillZoid(client));
    else if (stuff->data == X_SetZoidAlignment)
        return(ProcSetZoidAlignment(client));
    else
    {
        SendErrorToClient(client, ZoidReqCode, stuff->data, 0, BadRequest);
        return(BadRequest);
    }
}

int
SProcZoidDispatch(client)
    register ClientPtr client;
{
}

void
ZoidSwapReplyProc()
{
}

void
ZoidResetProc()
{
}

void
ZoidFreeState()
{
}

void
ZoidDeleteState()
{
}

/*
 *  Y aligned

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                       Page E-9
                                                        31 August 1987


 *
 *         [x1,y1]     [x2,y1]
 *            +-----------+
 *           /             \
 *          +---------------+
 *       [x3,y2]         [x4,y2]
 *
 *  X aligned
 *
 *              [x2,y3]
 *                 +
 *                /|
 *       [x1,y1] / |
 *              +  |
 *              |  |
 *              +  |
 *       [x1,y2] \ |
 *                \|
 *                 +
 *              [x2,y4]
 */
void
UseGCFillPoly(pDraw, pGC, pZoidState, ntraps, traps)
    DrawablePtr pDraw;
    GCPtr pGC;
    ZoidStatePtr pZoidState;
    int ntraps;
    xXYTraps *traps;
{
    DDXPointRec         zoidpoly[4];
    int                 i;

    for (i = 0; i < ntraps; i++, traps++) {
        if (pZoidState->alignment == XZoid_XAligned) {
            zoidpoly[0].x = traps->Xt.x1;
            zoidpoly[0].y = traps->Xt.y1;
            zoidpoly[1].x = traps->Xt.x2;
            zoidpoly[1].y = traps->Xt.y3;
            zoidpoly[2].x = traps->Xt.x2;
            zoidpoly[2].y = traps->Xt.y4;
            zoidpoly[3].x = traps->Xt.x1;
            zoidpoly[3].y = traps->Xt.y2;
        } else {
            zoidpoly[0].x = traps->Yt.x1;
            zoidpoly[0].y = traps->Yt.y1;
            zoidpoly[1].x = traps->Yt.x2;
            zoidpoly[1].y = traps->Yt.y1;
            zoidpoly[2].x = traps->Yt.x4;
            zoidpoly[2].y = traps->Yt.y2;
            zoidpoly[3].x = traps->Yt.x3;
            zoidpoly[3].y = traps->Yt.y2;
        }
        (*GetGCValue(pGC, FillPolygon)) (pDraw, pGC, Convex,
                                         CoordModeOrigin, 4, zoidpoly);

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                      Page E-10
                                                        31 August 1987


    }
}



E.4  CODE (ZOID.H)


/*
   ZOID uses the following defines to look up the correct procedure
   for its state block at ValidateGC time
*/

#define SOLID_Y     0
#define STIP_Y      1
#define TILE_Y      2
#define SOLID_X     3
#define STIP_X      4
#define TILE_X      5

/*
 * Protocol requests constants and alignment values
 * These would really be in ZOID's X.h and Xproto.h equivalents
 */

#define X_PolyFillZoid         1
#define X_SetZoidAlignment     2
#define XZoid_YAligned         1
#define XZoid_XAligned         2

typedef struct _PolyFillZoid {
    CARD8 reqType;          /* always ZoidReqCode */
    CARD8 zoidReqType;      /* always X_PolyFillZoid */
    CARD16 length;
    Drawable drawable;
    GContext gc;
} xPolyFillZoidReq;     /* followed by either xXTraps or xYTraps */

typedef struct _xYTraps {
    INT16 x1, x2, x3, x4, y1, y2;
} xYTraps;

typedef struct _xXTraps {
    INT16 y1, y2, y3, y4, x1, x2;
} xXTraps;

typedef union _xXYTraps {
    xXTraps Xt;
    xYTraps Yt;
} xXYTraps;

typedef struct _SetZoidAlignement {
    CARD8 reqType;          /* always ZoidReqCode */
    CARD8 zoidReqType;      /* always X_SetZoidAlignment */

ZOID--A SAMPLE EXTENSION IMPLEMENTATION                      Page E-11
                                                        31 August 1987


    CARD16 length;
    GContext gc;
    CARD8 alignment;
    CARD8 pad[3];           /* must be aligned on long words */
} xSetZoidAlignmentReq;

#define ZOIDNAME "ZoidExtension"


